# ì˜ì–´ìŠ¤í„°ë”” ì‹œì¦Œ 8ì£¼ì°¨

[document link](https://proandroiddev.com/mvvm-architecture-viewmodel-and-livedata-part-2-di-1a6b1f96d84b)

# ğŸ“— ë‹¨ì–´ ì •ë¦¬ ğŸ“˜

|ì˜ì–´|í•œê¸€|
|----|----|
|raised at| ~ì—ì„œ ì œê¸°|
|discuss|ë…¼ì˜ í•˜ë‹¤|
|self-explanatory|ìëª… í•˜ë‹¤|
|utilize |í™œìš© í•˜ë‹¤|
|refer to|ì¸ìš© í•˜ë‹¤|


# Part2   
   
During Google I/O, Google introduced architecture components which includes LiveData and ViewModel
which facilitates developing Android app using MVVM pattern.   
`Google I/O ë™ì•ˆ Googleì€ MVVM íŒ¨í„´ì„ ì‚¬ìš©í•˜ì—¬ Android ì•± ê°œë°œì„ ìš©ì´í•˜ê²Œ
í•˜ëŠ” LiveData ë° ViewModelì„ í¬í•¨í•˜ëŠ” ì•„í‚¤í…ì²˜ êµ¬ì„± ìš”ì†Œë¥¼ ë„ì…í–ˆìŠµë‹ˆë‹¤.`   
   
In the first article of this series, we discussed how can these components serve an android 
app that follows MVVM.   
`ì´ ì‹œë¦¬ì¦ˆì˜ ì²« ë²ˆì§¸ ê¸°ì‚¬ì—ì„œëŠ” ì´ëŸ¬í•œ êµ¬ì„± ìš”ì†Œê°€ MVVMì„ ë”°ë¥´ëŠ” Android ì•±ì„ ì œê³µí•˜ëŠ” ë°©ë²•ì— ëŒ€í•´ ë…¼ì˜í–ˆìŠµë‹ˆë‹¤.`   
   
In this second article, we will answer one of the questions that was raised at the end of the first
article which is Dependency injection.   
`ì´ ë‘ ë²ˆì§¸ ê¸°ì‚¬ì—ì„œëŠ” ì²« ë²ˆì§¸ ê¸°ì‚¬ì˜ ëì—ì„œ ì œê¸°ëœ ì§ˆë¬¸ ì¤‘ í•˜ë‚˜ì¸ ì¢…ì†ì„± ì£¼ì…ì— ëŒ€í•œ ë‹µë³€ì„ ì œê³µí•©ë‹ˆë‹¤.`   
   
This article assumes that you have a basic knowledge of Dagger since we will focus on setting up 
the latest Dagger version (version 2.11) in our MVVM sample in order to implement Dependency injection.   
`ì´ ë¬¸ì„œì—ì„œëŠ” ì¢…ì†ì„± ì£¼ì…ì„ êµ¬í˜„í•˜ê¸° ìœ„í•´ MVVM ìƒ˜í”Œì—ì„œ ìµœì‹  Dagger ë²„ì „(ë²„ì „ 2.11)ì„ ì„¤ì •í•˜ëŠ” ë°
ì¤‘ì ì„ ë‘˜ ê²ƒì´ê¸° ë•Œë¬¸ì— Daggerì— ëŒ€í•œ ê¸°ë³¸ ì§€ì‹ì´ ìˆë‹¤ê³  ê°€ì •í•©ë‹ˆë‹¤.`     
   
If you need basic information about Dagger 2.11, checkout Dagger user guide.   
`Dagger 2.11ì— ëŒ€í•œ ê¸°ë³¸ ì •ë³´ê°€ í•„ìš”í•œ ê²½ìš° Dagger ì‚¬ìš© ì„¤ëª…ì„œë¥¼ í™•ì¸í•˜ì„¸ìš”.`   
    
## Configuring Dagger 2.11   
`ëŒ€ê±° 2.11 êµ¬ì„±`    
   
First of all, letâ€™s add Dagger 2.11 dependencies to our MVVM Sample.   
`ì²«ë²ˆì§¸ë¡œ MVVM ìƒ˜í”Œì— Dagger 2.11 ì¢…ì†ì„±ì„ ì¶”ê°€í•´ ë³´ê² ìŠµë‹ˆë‹¤.`   
   
## Specify Dagger Version 2.11   
`ëŒ€ê±° ë²„ì „ 2.11 ì§€ì •`   
   
```
project.ext {
    // â€¦ 
    dagger_version = "2.11"
}
```   
   
## Including Dagger core   
`ëŒ€ê±° core í¬í•¨`   
   
```
annotationProcessor "com.google.dagger:dagger-compiler:$dagger_version"
compile "com.google.dagger:dagger:$project.dagger_version"
```   
   
## Including Dagger Android   
`ì•ˆë“œë¡œì´ë“œ ëŒ€ê±° í¬í•¨`   
   
```
compile "com.google.dagger:dagger-android:$project.dagger_version"
compile "com.google.dagger:dagger-android-support:$project.dagger_version"

annotationProcessor "com.google.dagger:dagger-android-processor:$dagger_version"
```
   
## Dagger 2.11 Project Setup
`Dagger 2.11 í”„ë¡œì íŠ¸ ì„¤ì •`   

The following figure shows the main Dagger 2.11 setup that we have in this sample.   
`ë‹¤ìŒ ê·¸ë¦¼ì€ ì´ ìƒ˜í”Œì— ìˆëŠ” ì£¼ìš” Dagger 2.11 ì„¤ì •ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.`   

![ì‚¬ì§„](mvvm_loner_7.png)    
    

We have mainly the following Dagger App classes/interfaces:   
`ì£¼ë¡œ ë‹¤ìŒê³¼ ê°™ì€ Dagger ì•± í´ë˜ìŠ¤/ì¸í„°í˜ì´ìŠ¤ê°€ ìˆìŠµë‹ˆë‹¤.`   
   
1. AppModule is a Dagger module responsible for providing singleton services on the 
   application level such as GitHubService and ProjectViewModelFactory.   
   `1. AppModuleì€ GitHubService ë° ProjectViewModelFactoryì™€ ê°™ì€ ì• í”Œë¦¬ì¼€ì´ì…˜ 
   ìˆ˜ì¤€ì—ì„œ ì‹±ê¸€í†¤ ì„œë¹„ìŠ¤ë¥¼ ì œê³µí•˜ëŠ” Dagger ëª¨ë“ˆì…ë‹ˆë‹¤.`    
   
2. AppComponent is responsible for injecting AppModule.   
   `2. AppComponentëŠ” AppModule ì£¼ì…ì„ ë‹´ë‹¹í•©ë‹ˆë‹¤.`   
   
3. ViewModelSubComponent is a sub component to create View Model instances.   
   `3. ViewModelSubComponentëŠ” View Model ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ê¸° ìœ„í•œ í•˜ìœ„ ì»´í¬ë„ŒíŠ¸ì…ë‹ˆë‹¤.`   
   
4. MainActivityModule and FragmentBuildersModule are activity and fragment instances providers.   
   `4. MainActivityModule ë° FragmentBuildersModuleì€ í™œë™ ë° í”„ë˜ê·¸ë¨¼íŠ¸ ì¸ìŠ¤í„´ìŠ¤ ì œê³µìì…ë‹ˆë‹¤.` 
   
5. Injectable is just a marker interface for fragments that will be injectable.   
    `5. Injectableì€ ì£¼ì… ê°€ëŠ¥í•œ ì¡°ê°ì— ëŒ€í•œ ë§ˆì»¤ ì¸í„°í˜ì´ìŠ¤ì¼ ë¿ì…ë‹ˆë‹¤.`   
   
6. AppInjector is a helper class to automatically inject fragments if they implement Injectable interface.   
   `6. AppInjectorëŠ” Injectable ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•˜ë©´ ìë™ìœ¼ë¡œ í”„ë˜ê·¸ë¨¼íŠ¸ë¥¼ ì£¼ì…í•˜ëŠ” ë„ìš°ë¯¸ í´ë˜ìŠ¤ì…ë‹ˆë‹¤.`

Now, letâ€™s get into the details of every Dagger item in this setup.   
`ì´ì œ ì´ ì„¤ì •ì˜ ëª¨ë“  Dagger í•­ëª©ì— ëŒ€í•´ ìì„¸íˆ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤.`   
   
## Creating View Model SubComponent   
`ë·° ëª¨ë¸ í•˜ìœ„ êµ¬ì„± ìš”ì†Œ ìƒì„±`   

The following code snippet shows ViewModelSubComponent interface, 
which is responsible for creating ViewModel instances.   
`ë‹¤ìŒ ì½”ë“œ ìŠ¤ë‹ˆí«ì€ ViewModel ì¸ìŠ¤í„´ìŠ¤ ìƒì„±ì„ ë‹´ë‹¹í•˜ëŠ” ViewModelSubComponent ì¸í„°í˜ì´ìŠ¤ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤.`   
   
```
@Subcomponent
public interface ViewModelSubComponent {
    @Subcomponent.Builder
    interface Builder {
        ViewModelSubComponent build();
    }

    ProjectListViewModel projectListViewModel();
    ProjectViewModel projectViewModel();
}
```   

Note that, ViewModelSubComponent will be called by ProjectViewModelFactory for 
getting ViewModel instances.   
`ì°¸ê³ ë¡œ, ViewModelSubComponentëŠ” ViewModel ì¸ìŠ¤í„´ìŠ¤ë¥¼ ê°€ì ¸ì˜¤ê¸° ìœ„í•´ ProjectViewModelFactoryì— ì˜í•´ í˜¸ì¶œë©ë‹ˆë‹¤.`   
   
### But what is ProjectViewModelFactory?   
`ê·¸ëŸ¬ë‚˜ ProjectViewModelFactoryëŠ” ë¬´ì—‡ì…ë‹ˆê¹Œ?`   

The next section answers this question.   
`ë‹¤ìŒ ì„¹ì…˜ì—ì„œëŠ” ì´ ì§ˆë¬¸ì— ë‹µí•©ë‹ˆë‹¤.`   

## Creating custom View Model Factory   
`ì»¤ìŠ¤í…€ ë·° ëª¨ë¸ íŒ©í† ë¦¬ ìƒì„±`   
   
ProjectViewModelFactory is a factory that extends ViewModelProvider.Factory in
order to provide ViewModel instances to consumer fragment classes.   
`ProjectViewModelFactoryëŠ” ViewModel ì¸ìŠ¤í„´ìŠ¤ë¥¼ 
ì†Œë¹„ì í”„ë˜ê·¸ë¨¼íŠ¸ í´ë˜ìŠ¤ì— ì œê³µí•˜ê¸° ìœ„í•´ ViewModelProvider.Factoryë¥¼ í™•ì¥í•˜ëŠ” íŒ©í† ë¦¬ì…ë‹ˆë‹¤.`   

The following code snippet shows ProjectViewModelFactory which is a self-explanatory Factory 
implementation that extends ViewModelProvider.Factory.   
`ë‹¤ìŒ ì½”ë“œ ì¡°ê°ì€ ViewModelProvider.Factoryë¥¼ í™•ì¥í•˜ëŠ” ìì²´ ì„¤ëª…ì´ ê°€ëŠ¥í•œ Factory êµ¬í˜„ì¸
ProjectViewModelFactoryë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤.`   
   
```
@Singleton
public class ProjectViewModelFactory implements ViewModelProvider.Factory {
    private final ArrayMap<Class, Callable<? extends ViewModel>> creators;

    @Inject
    public ProjectViewModelFactory(ViewModelSubComponent viewModelSubComponent) {
        creators = new ArrayMap<>();
        
        // View models cannot be injected directly because they won't be bound to the owner's
        // view model scope.
        creators.put(ProjectViewModel.class, () -> viewModelSubComponent.projectViewModel());
        creators.put(ProjectListViewModel.class, () -> viewModelSubComponent.projectListViewModel());
    }

    @Override
    public <T extends ViewModel> T create(Class<T> modelClass) {
        Callable<? extends ViewModel> creator = creators.get(modelClass);
        if (creator == null) {
            for (Map.Entry<Class, Callable<? extends ViewModel>> entry : creators.entrySet()) {
                if (modelClass.isAssignableFrom(entry.getKey())) {
                    creator = entry.getValue();
                    break;
                }
            }
        }
        if (creator == null) {
            throw new IllegalArgumentException("Unknown model class " + modelClass);
        }
        try {
            return (T) creator.call();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
```   

Now, letâ€™s see the main app module in the next section.   
`ì´ì œ ë‹¤ìŒ ì„¹ì…˜ì—ì„œ ì£¼ìš” ì•± ëª¨ë“ˆì„ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.`   

## Creating App Module   
`ì•± ëª¨ë“ˆ ìƒì„±`   
   
AppModule is a Dagger module responsible for providing singleton services 
on the application level such as GitHubService and
ProjectViewModelFactory to consumers.    
`AppModuleì€ GitHubService ë° ProjectViewModelFactoryì™€ ê°™ì€ ì• í”Œë¦¬ì¼€ì´ì…˜ ìˆ˜ì¤€ì˜ ì‹±ê¸€í†¤ ì„œë¹„ìŠ¤ë¥¼
ì†Œë¹„ìì—ê²Œ ì œê³µí•˜ëŠ” Dagger ëª¨ë“ˆì…ë‹ˆë‹¤.`    
   
The following code snippet shows AppModule class   
`ë‹¤ìŒ ì½”ë“œ ìŠ¤ë‹ˆí«ì€ AppModule í´ë˜ìŠ¤ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤.`   
   
```
@Module(subcomponents = ViewModelSubComponent.class)
class AppModule {
    @Singleton @Provides
    GitHubService provideGithubService() {
        return new Retrofit.Builder()
                .baseUrl(GitHubService.HTTPS_API_GITHUB_URL)
                .addConverterFactory(GsonConverterFactory.create())
                .build()
                .create(GitHubService.class);
    }

    @Singleton
    @Provides
    ViewModelProvider.Factory provideViewModelFactory(
            ViewModelSubComponent.Builder viewModelSubComponent) {

        return new ProjectViewModelFactory(viewModelSubComponent.build());
    }
}
```   

Something important here to note, do not forget to wire
ViewModelSubComponent to AppModule by specifying it in the
subcomponents parameter of @Module annotation.   
`ì—¬ê¸°ì„œ ì£¼ëª©í•´ì•¼ í•  ì¤‘ìš”í•œ ì‚¬í•­ì€ @Module ì£¼ì„ì˜ í•˜ìœ„ êµ¬ì„± ìš”ì†Œ ë§¤ê°œ ë³€ìˆ˜ì— ì§€ì •í•˜ì—¬ 
ViewModelSubComponentë¥¼ AppModuleì— ì—°ê²°í•˜ëŠ” ê²ƒì„ ìŠì§€ ë§ˆì‹­ì‹œì˜¤.`   
   
Creating Injectable and AppInjector   
`Injectable ë° AppInjector ë§Œë“¤ê¸°`   
   
Injectable interface is just a plain empty marker interface as follows.   
`ì£¼ì… ê°€ëŠ¥í•œ ì¸í„°í˜ì´ìŠ¤ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ê·¸ëƒ¥ ë¹„ì–´ ìˆëŠ” ì¼ë°˜ ë§ˆì»¤ ì¸í„°í˜ì´ìŠ¤ì…ë‹ˆë‹¤.`   
   
```
public interface Injectable {
}
```   

Injectable will be implemented by fragments which will be injectable.   
`Injectableì€ ì£¼ì… ê°€ëŠ¥í•œ ì¡°ê°ìœ¼ë¡œ êµ¬í˜„ë©ë‹ˆë‹¤.`   
   
In order to automatically inject fragments if they implement Injectable interface, 
the following AppInjector helper class is created to inject fragment instance on onFragmentCreated()
as follows.   
`Injectable ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•˜ë©´ ìë™ìœ¼ë¡œ í”„ë˜ê·¸ë¨¼íŠ¸ë¥¼ ì£¼ì…í•˜ê¸° ìœ„í•´
ë‹¤ìŒê³¼ ê°™ì´ onFragmentCreated()ì— í”„ë˜ê·¸ë¨¼íŠ¸ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì£¼ì…í•˜ê¸° ìœ„í•´ 
ë‹¤ìŒ AppInjector ë„ìš°ë¯¸ í´ë˜ìŠ¤ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.`   
   
```
public class AppInjector {
    private AppInjector() {}

    public static void init(MVVMApplication mvvmApplication) {
        DaggerAppComponent.builder().application(mvvmApplication)
                .build().inject(mvvmApplication);

        mvvmApplication
                .registerActivityLifecycleCallbacks(new Application.ActivityLifecycleCallbacks() {
                    @Override
                    public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
                        handleActivity(activity);
                    }

                    // Other methods are omitted for simplification â€¦
                });
    }

    private static void handleActivity(Activity activity) {
        if (activity instanceof HasSupportFragmentInjector) {
            AndroidInjection.inject(activity);
        }
        if (activity instanceof FragmentActivity) {
            ((FragmentActivity) activity).getSupportFragmentManager()
                    .registerFragmentLifecycleCallbacks(
                            new FragmentManager.FragmentLifecycleCallbacks() {
                                @Override
                                public void onFragmentCreated(FragmentManager fm, Fragment fragment,
                                                              Bundle savedInstanceState) {
                                    if (fragment instanceof Injectable) {
                                        AndroidSupportInjection.inject(fragment);
                                    }
                                }
                            }, true);
        }
    }
}
```   

One thing to note, AppInjector.init() will be called in App startup 
(as what we will show in Custom Application class section).   
`í•œ ê°€ì§€ ì£¼ì˜í•  ì ì€ AppInjector.init()ê°€ 
ì•± ì‹œì‘ ì‹œ í˜¸ì¶œëœë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤(ì‚¬ìš©ì ì§€ì • ì‘ìš© í”„ë¡œê·¸ë¨ í´ë˜ìŠ¤ ì„¹ì…˜ì—ì„œ í‘œì‹œí•  ë‚´ìš©).`   

## Creating Activity and Fragment Modules   
`ì•¡í‹°ë¹„í‹° ë° í”„ë ˆê·¸ë¨¼íŠ¸ ëª¨ë“ˆ ë§Œë“¤ê¸°`   
   
The following code snippets shows Fragments Dagger module.   
`ë‹¤ìŒ ì½”ë“œ ì¡°ê°ì€ Fragments Dagger ëª¨ë“ˆì„ ë³´ì—¬ì¤ë‹ˆë‹¤.`   
   
```
@Module
public abstract class FragmentBuildersModule {
    @ContributesAndroidInjector
    abstract ProjectFragment contributeProjectFragment();

    @ContributesAndroidInjector
    abstract ProjectListFragment contributeProjectListFragment();
}
```   

Starting from Dagger 2.10, @ContributesAndroidInjector easily attaches activities and fragments
to dagger graph.   
`Dagger 2.10ë¶€í„° @ContributesAndroidInjectorëŠ” ì•¡í‹°ë¹„í‹°ì™€ í”„ë˜ê·¸ë¨¼íŠ¸ë¥¼ dagger ê·¸ë˜í”„ì— ì‰½ê²Œ ì²¨ë¶€í•©ë‹ˆë‹¤.`   
   

The following code snippet shows MainActivityModule.   
`ë‹¤ìŒ ì½”ë“œ ì¡°ê°ì€ MainActivityModuleì„ ë³´ì—¬ì¤ë‹ˆë‹¤.`   
   
```
@Module
public abstract class MainActivityModule {
    @ContributesAndroidInjector(modules = FragmentBuildersModule.class)
    abstract MainActivity contributeMainActivity();
}
```

Now, letâ€™s look into the last item in our Dagger 2.11 setup, which is, AppComponent.   
`ì´ì œ Dagger 2.11 ì„¤ì •ì˜ ë§ˆì§€ë§‰ í•­ëª©ì¸ AppComponentë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.`   

## Creating AppComponent   
`ì•± ì»´í¬ë„ŒíŠ¸ ìƒì„±`   
   
The next code snippet shows AppComponent interface.   
`ë‹¤ìŒ ì½”ë“œ ì¡°ê°ì€ AppComponent ì¸í„°í˜ì´ìŠ¤ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤.`   
   
```

@Singleton
@Component(modules = {
        AndroidInjectionModule.class,
        AppModule.class,
        MainActivityModule.class
})
public interface AppComponent {
    @Component.Builder
    interface Builder {
        @BindsInstance Builder application(Application application);
        AppComponent build();
    }
    void inject(MVVMApplication mvvmApplication);
}
```   
One thing important to note here, adding to including AppModule and MainActivityModule,
we added AndroidSupportInjectionModule to AppComponent as per the official documentation
that states that it is necessary in order to ensure that all necessary bindings are available.   
`ì—¬ê¸°ì„œ ì£¼ëª©í•´ì•¼ í•  ì¤‘ìš”í•œ í•œ ê°€ì§€ëŠ” AppModule ë° MainActivityModuleì„ 
í¬í•¨í•˜ëŠ” ê²ƒ ì™¸ì— í•„ìš”í•œ ëª¨ë“  ë°”ì¸ë”©ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ í•˜ê¸° ìœ„í•´ í•„ìš”í•˜ë‹¤ëŠ” ê³µì‹ ë¬¸ì„œì— ë”°ë¼
AppComponentì— AndroidSupportInjectionModuleì„ ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.`   
   
AndroidSupportInjectionModule is a built-in module in dagger-android:   
`AndroidSupportInjectionModuleì€ dagger-androidì— ë‚´ì¥ëœ ëª¨ë“ˆì…ë‹ˆë‹¤.`   

[AndroidSupportInjectionModuleê¹ƒí—ˆë¸Œ](https://github.com/google/dagger/blob/master/java/dagger/android/support/AndroidSupportInjectionModule.java)   

## Updating Repository Layer Implementation
`ë¦¬í¬ì§€í† ë¦¬ ê³„ì¸µ êµ¬í˜„ ì—…ë°ì´íŠ¸`   

Now, we are done from setting up Dagger 2.11, 
letâ€™s update our existing app code in order to utilize Dagger dependency injection.   
`ì´ì œ Dagger 2.11 ì„¤ì •ì„ ë§ˆì³¤ìŠµë‹ˆë‹¤. Dagger ì¢…ì†ì„± ì£¼ì…ì„ í™œìš©í•˜ê¸° ìœ„í•´ ê¸°ì¡´ ì•± ì½”ë“œë¥¼ ì—…ë°ì´íŠ¸í•˜ê² ìŠµë‹ˆë‹¤.`   
   
ProjectRepository will not have to create GitHubService service instance manually anymore,
all what it needs to do is to use @Inject in its constructor for GitHubService instance as shown below.   
`ProjectRepositoryëŠ” ë” ì´ìƒ GitHubService ì„œë¹„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìˆ˜ë™ìœ¼ë¡œ ìƒì„±í•  í•„ìš”ê°€ ì—†ìœ¼ë©° 
ì•„ë˜ í‘œì‹œëœ ê²ƒì²˜ëŸ¼ GitHubService ì¸ìŠ¤í„´ìŠ¤ìš© ìƒì„±ìì—ì„œ @Injectë¥¼ ì‚¬ìš©í•˜ê¸°ë§Œ í•˜ë©´ ë©ë‹ˆë‹¤.`   
   
```
@Singleton
public class ProjectRepository {
    private GitHubService gitHubService;

    @Inject
    public ProjectRepository(GitHubService gitHubService) {
        this.gitHubService = gitHubService;
    }

    // Other methods here are omitted for simplicity â€¦
}
```   

## Updating ViewModel Layer Implementation   
`ViewModel ë ˆì´ì–´ êµ¬í˜„ ì—…ë°ì´íŠ¸`  

Updating ViewModel layer is also necessary to avoid creating an instance 
from ProjectRepository manually inside this layer.   
`ì´ ë ˆì´ì–´ ë‚´ì—ì„œ ìˆ˜ë™ìœ¼ë¡œ ProjectRepositoryì—ì„œ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ì§€ 
ì•Šìœ¼ë ¤ë©´ ViewModel ë ˆì´ì–´ë¥¼ ì—…ë°ì´íŠ¸í•´ì•¼ í•©ë‹ˆë‹¤.`   
      
The following code snippet shows an example from ProjectViewModel which uses
@inject annotation to have both Application and ProjectRepository instances injected.   
`ë‹¤ìŒ ì½”ë“œ ì¡°ê°ì€ @inject ì£¼ì„ì„ ì‚¬ìš©í•˜ì—¬ Application ë° ProjectRepository
ì¸ìŠ¤í„´ìŠ¤ë¥¼ ëª¨ë‘ ì£¼ì…í•˜ëŠ” ProjectViewModelì˜ ì˜ˆë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤.`   
   
```
public class ProjectViewModel extends AndroidViewModel {
    private static final String TAG = ProjectViewModel.class.getName();
    private static final MutableLiveData ABSENT = new MutableLiveData();
    {
        //noinspection unchecked
        ABSENT.setValue(null);
    }

    private final LiveData<Project> projectObservable;
    private final MutableLiveData<String> projectID;

    public ObservableField<Project> project = new ObservableField<>();

    @Inject
    public ProjectViewModel(@NonNull ProjectRepository projectRepository, @NonNull Application application) {
        super(application);

        this.projectID = new MutableLiveData<>();

        projectObservable = Transformations.switchMap(projectID, input -> {
            if (input.isEmpty()) {
                return ABSENT;
            }

            return projectRepository.getProjectDetails("Google", projectID.getValue());
        });
    }

    // Code is omitted for simplicity â€¦
}
```   

Updating View Implementation (Fragments and Main Activity)   
`ë·° êµ¬í˜„ ì—…ë°ì´íŠ¸(í”„ë˜ê·¸ë¨¼íŠ¸ ë° ê¸°ë³¸ í™œë™)`   
   
Updating View layer is also necessary to avoid
creating instances from ViewModel classes manually inside this layer.   
`ì´ ê³„ì¸µ ë‚´ì—ì„œ ìˆ˜ë™ìœ¼ë¡œ ViewModel í´ë˜ìŠ¤ì—ì„œ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ì§€ ì•Šìœ¼ë ¤ë©´ View ê³„ì¸µì„ ì—…ë°ì´íŠ¸í•´ì•¼ í•©ë‹ˆë‹¤.`   
   
The following code snippet shows an example from ProjectFragment.   
`ë‹¤ìŒ ì½”ë“œ ìŠ¤ë‹ˆí«ì€ ProjectFragmentì˜ ì˜ˆë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤.`   
   
```

public class ProjectFragment extends LifecycleFragment implements Injectable {

    @Inject
    ViewModelProvider.Factory viewModelFactory;


    @Override
    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        final ProjectViewModel viewModel = ViewModelProviders.of(this, viewModelFactory)
                .get(ProjectViewModel.class);

        // â€¦
    }

    // â€¦
}
```   

Some important points to note here:
`ì—¬ê¸°ì—ì„œ ì£¼ì˜í•´ì•¼ í•  ëª‡ ê°€ì§€ ì¤‘ìš”í•œ ì‚¬í•­:`   

1. Every fragment now must implement Injectable Interface.
   `1. ì´ì œ ëª¨ë“  í”„ë ˆê·¸ë¨¼íŠ¸ëŠ” ì£¼ì… ê°€ëŠ¥í•œ ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤.`   
   
2. Fragment classes should refer to ViewModelProvider.Factory in order to get ViewModel instances.   
   `2. í”„ë˜ê·¸ë¨¼íŠ¸ í´ë˜ìŠ¤ëŠ” ViewModel ì¸ìŠ¤í„´ìŠ¤ë¥¼ ê°€ì ¸ì˜¤ê¸° ìœ„í•´ ViewModelProvider.Factoryë¥¼ ì°¸ì¡°í•´ì•¼ í•©ë‹ˆë‹¤.`   

## Creating Custom Application class   
`ì»¤ìŠ¤í…€ ì• í”Œë¦¬ì¼€ì´ì…˜ í´ë˜ìŠ¤ ìƒì„±`   
   
Finally, our custom application class code is shown below.   
`ë§ˆì§€ë§‰ìœ¼ë¡œ ì»¤ìŠ¤í…€í•œ ì–´í”Œë¦¬ì¼€ì´ì…˜ í´ë˜ìŠ¤ ì½”ë“œê°€ ì•„ë˜ì— ë‚˜ì™€ ìˆìŠµë‹ˆë‹¤.`   
   
```
public class MVVMApplication extends Application implements HasActivityInjector {

    @Inject
    DispatchingAndroidInjector<Activity> dispatchingAndroidInjector;

    @Override
    public void onCreate() {
        super.onCreate();
        AppInjector.init(this);
    }

    @Override
    public DispatchingAndroidInjector<Activity> activityInjector() {
        return dispatchingAndroidInjector;
    }
}
```   

Two main things to note here:   
`ì—¬ê¸°ì„œ ì£¼ëª©í•´ì•¼ í•  ë‘ ê°€ì§€ ì£¼ìš” ì‚¬í•­:`   

1. Application class has to implement HasActivityInjector, and @Inject a DispatchingAndroidInjector<Activity> to return from the activityInjector() method.   
   `1. Application í´ë˜ìŠ¤ëŠ” HasActivityInjectorë¥¼ êµ¬í˜„í•´ì•¼ í•˜ë©°, @Inject a DispatchingAndroidInjector<Activity> ë¥¼ activityInjector() ë©”ì„œë“œì—ì„œ ë°˜í™˜í•´ì•¼ í•©ë‹ˆë‹¤.`

2. In the onCreate() of Application class, we initialize AppInjector in order to automatically inject fragments if they implement Injectable interface.   
`2. Application í´ë˜ìŠ¤ì˜ onCreate()ì—ì„œ Injectable ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•œ í”„ë˜ê·¸ë¨¼íŠ¸ë¥¼ ìë™ìœ¼ë¡œ ì£¼ì…í•˜ê¸° ìœ„í•´ AppInjectorë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.`    
   

[ì „ì²´ ìƒ˜í”Œ ì½”ë“œ](https://github.com/hazems/mvvm-sample-app/tree/part2)