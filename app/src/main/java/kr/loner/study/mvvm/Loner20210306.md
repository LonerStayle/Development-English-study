# ì˜ì–´ìŠ¤í„°ë”” ì‹œì¦Œ 6ì£¼ì°¨

[document link](https://proandroiddev.com/mvvm-architecture-viewmodel-and-livedata-part-1-604f50cda1)

# ğŸ“— ë‹¨ì–´ ì •ë¦¬ ğŸ“˜

|ì˜ì–´|í•œê¸€|
|----|----|
|rigid|ì—„ê²©í•œ|
|explicit|ëª…ë°±í•œ|
|completely|ì™„ì „íˆ|
|benefit|í˜œíƒ|
|instead|ëŒ€ì‹ ì—|

## LiveData

`ë¼ì´ë¸Œ ë°ì´í„°`

As said above, LiveData is one of the newly introduced architecture components.   
`ìœ„ì—ì„œ ë§í–ˆë“¯ì´, ë¼ì´ë¸Œë°ì´í„°ëŠ” ìƒˆë¡œ ë„ì…ëœ ì•„í‚¤í…ì²˜ ì»´í¬ë„ŒíŠ¸ ì¤‘ì˜ í•˜ë‚˜ ì…ë‹ˆë‹¤.`

LiveData is an observable data holder.   
`ë¼ì´ë¸Œë°ì´í„°ëŠ” ê´€ì°°í•˜ëŠ” ë°ì´í„° í™€ë” ì…ë‹ˆë‹¤.`

This allows the components in your app to be able to observe LiveData objects for changes without
creating explicit and rigid dependency paths between them.   
`ì´ë ‡ê²Œ í•˜ë©´ ì•±ì˜ ì»´í¬ë„ŒíŠ¸ê°€ LiveData ê°ì²´ ê°„ì˜ ëª…ì‹œì ì´ê³  ì—„ê²©í•œ ì¢…ì†ì„± ê²½ë¡œë¥¼ ë§Œë“¤ì§€ ì•Šê³ ë„ ë³€ê²½ì‚¬í•­ì„ ê´€ì°° í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`

- í•´ì„ì´ ì–´ë ¤ì›€..

This decouples completely the LiveData object producer from the LiveData object consumer.   
`ì´ê²ƒì€ ë¼ì´ë¸Œë°ì´í„° ê°ì²´ ìƒì‚°ìì™€ ë¼ì´ë¸Œë°ì´í„° ê°ì²´ ì†Œë¹„ìê°€ ì™„ì „íˆ ê²°í•©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.`

Adding to this, there is also a great benefit in LiveData, LiveData respects the lifecycle state of
your app components (activities, fragments, services)
and handles object life cycle management which ensures that LiveData objects do not leak.   
`ì¶”ê°€ë¡œ, ì´ê²ƒì€ ë˜í•œ ë¼ì´ë¸Œë°ì´í„°ì˜ ì¢‹ì€ í˜œíƒ ì´ë©°, ë¼ì´ë¸Œë°ì´í„°ëŠ” ì•±ì˜ ì»´í¬ë„ŒíŠ¸ì˜ ë¼ì´ë¸Œì‚¬ì´í´ ìƒíƒœë¥¼ ì¡´ì¤‘í•˜ê³  ë¼ì´ë¸Œë°ì´í„° ê°ì²´ê°€ ëˆ„ìˆ˜ê°€ ì—†ë„ë¡ ê°ì²´ì˜ ë¼ì´í”„ ì‚¬ì´í´ ê´€ë¦¬í•´ì„œ ì²˜ë¦¬í•©ë‹ˆë‹¤.`

As per Google Docs,   
`êµ¬ê¸€ ë¬¸ì„œì— ë”°ë¼,`

If you are already using a library like Rx or Agera, you can continue using them instead of
LiveData.  
`ë§Œì•½ RXë‚˜ Agera ê°™ì€ ë¼ì´ë¸Œë°ì´í„°ë¥¼ í•­ìƒ ì‚¬ìš©ì¤‘ì´ë©´, ë¼ì´ë¸Œë°ì´í„°ë¥¼ ëŒ€ì‹ í•´ì„œ ì—¬ì „íˆ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`

But in this case, it is your responsibility to handle object allocation and de-allocation per
Android components life cycle.   
`í•˜ì§€ë§Œ ì´ëŸ° ì¼€ì´ìŠ¤ëŠ” ì•ˆë“œë¡œì´ë“œ ì»´í¬ë„ŒíŠ¸ ë¼ì´í”„ì‚¬ì´í´ì— ë”°ë¼ ê°ì²´ì˜ í• ë‹¹ í˜¹ì€ ë¹„í• ë‹¹ ì²˜ë¦¬ë¥¼ ë‹¹ì‹ ì´ í•´ì•¼í•  ì±…ì„ì´ ìƒê¹ë‹ˆë‹¤. `

Since LiveData respects Android Lifecycle, this means it will not invoke its observer callback
unless the LiveData host (activity or fragment)
is in an active state (received onStart() but did not receive onStop() for example).   
`ë•Œë¬¸ì— ë¼ì´ë¸Œë°ì´íŠ¸ëŠ” ì•ˆë“œë¡œì´ë“œ ë¼ì´í”„ì‚¬ì´í´ì„ ì¡´ì¤‘í•˜ê³ , ì´ ì˜ë¯¸ëŠ” LiveData í˜¸ìŠ¤íŠ¸ê°€ í™œì„±ìƒíƒœê°€ ì•„ë‹ˆë©´ (onStartëŠ” ìˆ˜ì‹ í–ˆì§€ë§Œ onStopì€ ìˆ˜ì‹  í•˜ì§€ ì•Šì„ ê²½ìš°) ì˜µì €ë²„ ì½œë°±ì€ í˜¸ì¶œí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.`

Adding to this,   
`ì¶”ê°€ë¡œ `

LiveData will also automatically remove the observer when the its host receives onDestroy().   
`ë¼ì´ë¸Œë°ì´í„°ëŠ” í˜¸ìŠ¤íŠ¸ê°€ onDestroy()ë¥¼ ìˆ˜ì‹ í•˜ì˜€ì„ ë•Œ ìë™ìœ¼ë¡œ ì˜µì €ë²„ëŠ” ì œê±° ë  ê²ƒ ì…ë‹ˆë‹¤.`

LiveData will be illustrated in our MVVM sample app below.   
`ë¼ì´ë¸Œ ë°ì´í„°ëŠ” ì•„ë˜ ì•± MVVM ìƒ˜í”Œì— ì„¤ëª… ë˜ì–´ ìˆìŠµë‹ˆë‹¤. `

## ViewModel

`ë·°ëª¨ë¸`

ViewModel is also one of the newly introduced architecture components.   
`ë·°ëª¨ë¸ ë˜í•œ ì•„í‚¤í…ì²˜ êµ¬ì„±ìš”ì†Œì¤‘ì˜ ë„ì…ëœ ê²ƒì¤‘ í•˜ë‚˜ ì…ë‹ˆë‹¤.`

Architecture components provide a new class called ViewModel, which is responsible for preparing the
data for the UI/View.   
`ì•„í‚¤í…ì³ ì»´í¬ë„ŒíŠ¸ëŠ” UI/VIEWì˜ ë°ì´í„°ë¥¼ ì¤€ë¹„í•˜ëŠ” ì±…ì„ì„ ê°€ì§„ ìƒˆë¡œìš´ í´ë˜ìŠ¤ ë·°ëª¨ë¸ì„ ì œê³µí•©ë‹ˆë‹¤.`

ViewModel gives you a good base class for your MVVM ViewModel layer since ViewModel
(and its children AndroidViewModel)â€™s extending classes are automatically having their holding data
retained during configuration changes.   
`ViewModel(ë° ê·¸ ìì‹ AndroidViewModel)ì˜ í™•ì¥ í´ë˜ìŠ¤ëŠ” êµ¬ì„± ë³€ê²½ ì¤‘ì— ë³´ìœ  ë°ì´í„°ê°€ ìë™ìœ¼ë¡œ ìœ ì§€ë˜ê¸° ë•Œë¬¸ì— ViewModelì€ MVVM ViewModel ë ˆì´ì–´ì— ëŒ€í•œ ì¢‹ì€ ê¸°ë³¸ í´ë˜ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤.`

This means that after configuration changes, this ViewModel holded data is immediately available to
the next activity or fragment instance.   
`êµ¬ì„± ë³€ê²½ í›„ì— ë·°ëª¨ë¸ì´ í™€ë“œí•œ ë°ì´í„°ëŠ” ë‹¤ìŒ ì•¡í‹°ë¹„í‹° í˜¹ì€ í”„ë ˆê·¸ë¨¼íŠ¸ ì¸ìŠ¤í„´ìŠ¤ì—ì„œ ì¦‰ì‹œ ì‚¬ìš©í•  ìˆ˜ ìˆìŒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.`

The following diagram shows the life cycle of ViewModel component.   
`ë‹¤ìŒ ë‹¤ì´ì–¼ê·¸ë¨ì€ ë·°ëª¨ë¸ ì»´í¬ë„ŒíŠ¸ì˜ ë¼ì´í”„ì‚¬ì´í´ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.`

![ì‚¬ì§„](mvvm_loner_2.png)

## Sample App

`ìƒ˜í”Œ ì•±`

Now, letâ€™s come the most interesting part, letâ€™s put all of these things together in a sample
app.   
`ì´ì œ, ê°€ì¥ í¥ë¯¸ë¡œìš´ ë¶€ë¶„ìœ¼ë¡œ ê°€ë´…ì‹œë‹¤, ì´ ëª¨ë“ ê²ƒë“¤ì„ ìƒ˜í”Œì•±ì— ë„£ì–´ì„œ í•¨ê»˜ í•´ë³´ê² ìŠµë‹ˆë‹¤.`

This MVVM Sample app contains mainly two screens.   
`ì´ê²ƒì€ MVVM ìƒ˜í”Œ ì•±ì— í¬í•¨ëœ ì£¼ìš” ë‘ê°œì˜ í™”ë©´ ì…ë‹ˆë‹¤. `

The first screen which is shown below displays the list of Google GitHub projects with some brief
information such as title, programming language, and finally number of watcher.   
`ì•„ë˜ì— í‘œì‹œëœ ì²« ë²ˆì§¸ í™”ë©´ì€ ì œëª©, í”„ë¡œê·¸ë˜ë° ì–¸ì–´ ë° ìµœì¢…ì ìœ¼ë¡œ í™•ì¸í•œ ìˆ˜ì™€ ê°™ì€ ëª‡ ê°€ì§€ ê°„ë‹¨í•œ ì •ë³´ì™€ í•¨ê»˜ Google GitHub í”„ë¡œì íŠ¸ ëª©ë¡ì„ í‘œì‹œí•©ë‹ˆë‹¤.`

![ì‚¬ì§„](mvvm_loner_3.png)

Once the appâ€™s end user touch any of the list items, a details screen of the GitHub project appears
displaying project description, programming language, number of watcher, open issues, creation and
last update date, and finally the clone URL.   
`ì•±ì˜ ìµœì¢… ì‚¬ìš©ìê°€ ëª©ë¡ í•­ëª©ì„ í„°ì¹˜í•˜ë©´ í”„ë¡œì íŠ¸ ì„¤ëª…, í”„ë¡œê·¸ë˜ë° ì–¸ì–´, ê°ì‹œì ìˆ˜, ë¯¸í•´ê²° ë¬¸ì œ, ìƒì„± ë° ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ ë‚ ì§œ, ë§ˆì§€ë§‰ìœ¼ë¡œ ë³µì œ URLì„ í‘œì‹œí•˜ëŠ” GitHub í”„ë¡œì íŠ¸ì˜ ì„¸ë¶€ ì •ë³´ í™”ë©´ì´ ë‚˜íƒ€ë‚©ë‹ˆë‹¤.`

![ì‚¬ì§„](mvvm_loner_4.png)

## Sample App Interaction Diagram

`ìƒ˜í”Œ ì•±ì— ë„ì…ëœ ë‹¤ì´ì–´ê·¸ë¨ ì…ë‹ˆë‹¤.`

The following figure shows the package structure of the Sample App   
`ë‹¤ìŒ ê·¸ë¦¼ì€ ìƒ˜í”Œ ì•±ì˜ íŒ¨í‚¤ì§€ êµ¬ì¡°ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.`

![ì‚¬ì§„](mvvm_loner_5.png)

The following interaction diagram shows a sample interaction diagram of one of the app scenarios to
retrieve Google GitHub projects.   
`ë‹¤ìŒ ìƒí˜¸ì‘ìš© ë‹¤ì´ì–´ê·¸ë¨ì€ Google GitHub í”„ë¡œì íŠ¸ë¥¼ ê²€ìƒ‰í•˜ê¸° ìœ„í•œ ì•± ì‹œë‚˜ë¦¬ì˜¤ ì¤‘ í•˜ë‚˜ì˜ ìƒ˜í”Œ ìƒí˜¸ì‘ìš© ë‹¤ì´ì–´ê·¸ë¨ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.`

![ì‚¬ì§„](mvvm_loner_6.png)

As shown in the diagram, every layer observes LiveData from its subsequent layer (Fragment (View) ->
ViewModel -> Repository), and finally once project list is retrieved, it is binded with the
RecyclerView adapter to display the project list.   
`ë‹¤ì´ì–´ê·¸ë¨ê³¼ ê°™ì´ ëª¨ë“  ê³„ì¸µì€ í›„ì† ê³„ì¸µ(Fragment(View) -> ViewModel -> Repository)ì—ì„œ LiveDataë¥¼ ê´€ì°°í•˜ê³  ë§ˆì§€ë§‰ìœ¼ë¡œ í”„ë¡œì íŠ¸ ëª©ë¡ì´ ê²€ìƒ‰ë˜ë©´ RecyclerView ì–´ëŒ‘í„°ì™€ ë°”ì¸ë”©ë˜ì–´ í”„ë¡œì íŠ¸ ëª©ë¡ì„ í‘œì‹œí•©ë‹ˆë‹¤.`

Repository modules are responsible should handle data operations.   
`ë ˆí¬ì§€í† ë¦¬ ëª¨ë“ˆì€ ë°ì´í„°ì˜ ìš´ì˜ì„ ì²˜ë¦¬í•  ì±…ì„ì´ ìˆìŠµë‹ˆë‹¤.`

By ensuring this, Repository modules can provide a clean API to the rest of the app and simplify the
job of the consumer ViewModel.    
`ì´ë¥¼ ë³´ì¥í•¨ìœ¼ë¡œì¨ ë¦¬í¬ì§€í† ë¦¬ ëª¨ë“ˆì€ ì•±ì˜ ë‚˜ë¨¸ì§€ ë¶€ë¶„ì— ê¹¨ë—í•œ APIë¥¼ ì œê³µí•˜ê³  ì†Œë¹„ì ViewModelì˜ ì‘ì—…ì„ ë‹¨ìˆœí™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`

Repository modules should know where to get the data from and what API calls to make when data is
updated if necessary.    
`ë¦¬í¬ì§€í† ë¦¬ ëª¨ë“ˆì€ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¬ ìœ„ì¹˜ì™€ í•„ìš”í•œ ê²½ìš° ë°ì´í„°ê°€ ì—…ë°ì´íŠ¸ë  ë•Œ ìˆ˜í–‰í•  API í˜¸ì¶œì„ ì•Œì•„ì•¼ í•©ë‹ˆë‹¤.`

They can be considered as mediators between different data sources
(REST services, Databases, XML files, â€¦etc).   
`ì„œë¡œ ë‹¤ë¥¸ ë°ì´í„° ì†ŒìŠ¤ ê°„ì˜ ì¤‘ì¬ìë¡œ ê°„ì£¼ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`

Now, letâ€™s explain these layers from bottom to up, starting with Model, ViewModel and finally View
for retrieving GitHub projects scenario   
`ì´ì œ Model, ViewModel ë° ë§ˆì§€ë§‰ìœ¼ë¡œ GitHub í”„ë¡œì íŠ¸ ê²€ìƒ‰ì„ ìœ„í•œ View ì‹œë‚˜ë¦¬ì˜¤ë¡œ ì‹œì‘í•˜ì—¬ ì´ëŸ¬í•œ ê³„ì¸µì„ ì•„ë˜ì—ì„œ ìœ„ë¡œ ì„¤ëª…í•˜ê² ìŠµë‹ˆë‹¤.`

## Sample App Model Layer

`ìƒ˜í”Œ ì•±ì˜ ëª¨ë¸ ê³„ì¸µ`

Letâ€™s start with the business logic layer, we have two model objects   
`ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ë ˆì´ì–´ë¶€í„° ì‹œì‘í•˜ê² ìŠµë‹ˆë‹¤. ë‘ ê°œì˜ ëª¨ë¸ ê°œì²´ê°€ ìˆìŠµë‹ˆë‹¤.`

1. Project, contains the information of GitHub project such as id, name, description, creation date,
   â€¦etc.   
   `1. í”„ë¡œì íŠ¸, id, ì´ë¦„, ì„¤ëª…, ìƒì„± ë‚ ì§œ ë“±ê³¼ ê°™ì€ GitHub í”„ë¡œì íŠ¸ ì •ë³´ê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤.`

2. User, contains the user information of the GitHub project owner.   
   `ì‚¬ìš©ì, GitHub í”„ë¡œì íŠ¸ ì†Œìœ ìì˜ ì‚¬ìš©ì ì •ë³´ë¥¼ í¬í•¨í•©ë‹ˆë‹¤.`

In order to interact with GitHub RESTful API, I used my beloved Retrofit 2 defining the following
simple interface under repository package.   
`GitHub RESTful APIì™€ ìƒí˜¸ ì‘ìš©í•˜ê¸° ìœ„í•´ ì €ì¥ì†Œ íŒ¨í‚¤ì§€ ì•„ë˜ì— ë‹¤ìŒê³¼ ê°™ì€ ê°„ë‹¨í•œ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì •ì˜í•˜ëŠ” ë‚´ê°€ ì‚¬ë‘í•˜ëŠ” Retrofit 2ë¥¼ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.`

```
interface GitHubService {
    String HTTPS_API_GITHUB_URL = "https://api.github.com/";

    @GET("users/{user}/repos")
    Call<List<Project>> getProjectList(@Path("user") String user);

    @GET("/repos/{user}/{reponame}")
    Call<Project> getProjectDetails(@Path("user") String user, @Path("reponame") String projectName);
}
```

In order to facilitate the Job of the ViewModel, a ProjectRepository class is created to interact
with GitHub service and to finally provide a LiveData object for ViewModel.
`ViewModelì˜ ì‘ì—…ì„ ìš©ì´í•˜ê²Œ í•˜ê¸° ìœ„í•´ GitHub ì„œë¹„ìŠ¤ì™€ ìƒí˜¸ ì‘ìš©í•˜ê³  ë§ˆì§€ë§‰ìœ¼ë¡œ ViewModelì— ëŒ€í•œ LiveData ê°œì²´ë¥¼ ì œê³µí•˜ê¸° ìœ„í•´ ProjectRepository í´ë˜ìŠ¤ê°€ ìƒì„±ë©ë‹ˆë‹¤.`

It will be also used later to orchestrate service calls.   
`ë˜í•œ ë‚˜ì¤‘ì— ì„œë¹„ìŠ¤ í˜¸ì¶œì„ ì¡°ì •í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.`

The following code snippet shows getProjectList() API implementation.   
`ë‹¤ìŒ ì½”ë“œ ì¡°ê°ì€ getProjectList() API êµ¬í˜„ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.`

```
public class ProjectRepository {
    private GitHubService gitHubService;

    //â€¦

    public LiveData<List<Project>> getProjectList(String userId) {
        final MutableLiveData<List<Project>> data = new MutableLiveData<>();

        gitHubService.getProjectList(userId).enqueue(new Callback<List<Project>>() {
            @Override
            public void onResponse(Call<List<Project>> call, Response<List<Project>> response) {
                data.setValue(response.body());
            }

            // Error handling will be explained in the next article â€¦
        });

        return data;
    }
    
    // â€¦
}
```

ProjectRepository is the data provider for ViewModel, it has getProjectList() which simply wraps the
response into LiveData Object.   
`ProjectRepositoryëŠ” ViewModelì˜ ë°ì´í„° ì œê³µìì´ë©°, ë‹¨ìˆœíˆ LiveData Objectì— ì‘ë‹µì„ ë˜í•‘í•˜ëŠ” getProjectList()ê°€ ìˆìŠµë‹ˆë‹¤.`

For the purpose of simplicity of this article, error handling is omitted, and will be illustrated in
the next article.   
`ì´ ë¬¸ì„œì˜ í¸ì˜ë¥¼ ìœ„í•´ ì˜¤ë¥˜ ì²˜ë¦¬ëŠ” ìƒëµí–ˆìœ¼ë©° ë‹¤ìŒ ë¬¸ì„œì—ì„œ ì„¤ëª…í•©ë‹ˆë‹¤.`

[ìƒ˜í”Œë§í¬](https://developer.android.com/topic/libraries/architecture/livedata.html#transformations_of_livedata)

## Sample App ViewModel Layer

`ìƒ˜í”Œ ì•±ì˜ ë·°ëª¨ë¸ ê³„ì¸µ`

In order to consume getProjectList() API, a ViewModel class (that calls the Repository API and may
do any needed transformation for LiveData) is created.   
`getProjectList() APIë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„œëŠ”, ViewModel í´ë˜ìŠ¤(Repository APIë¥¼ í˜¸ì¶œí•˜ê³  LiveDataì— í•„ìš”í•œ ë³€í™˜ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆìŒ)ê°€ ìƒì„±ë©ë‹ˆë‹¤.`

The following code snippet shows ProjectListViewModel class.   
`ë‹¤ìŒ ì½”ë“œ ì¡°ê°ì€ ProjectListViewModel í´ë˜ìŠ¤ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤.`

```
public class ProjectListViewModel extends AndroidViewModel {
    private final LiveData<List<Project>> projectListObservable;

    public ProjectListViewModel(Application application) {
        super(application);

        // If any transformation is needed, this can be simply done by Transformations class ...
        projectListObservable = ProjectRepository.getInstance().getProjectList("Google");
    }

    /**
     * Expose the LiveData Projects query so the UI can observe it.
     */
    public LiveData<List<Project>> getProjectListObservable() {
        return projectListObservable;
    }
}
```

As shown above, our ProjectListViewModel class extends AndroidViewModel, and in the constructor, it
calls getProjectList(â€œGoogleâ€) to retrieve Google GitHub projects.   
`ìœ„ì™€ ê°™ì´ ProjectListViewModel í´ë˜ìŠ¤ëŠ” AndroidViewModelì„ í™•ì¥í•˜ê³  ìƒì„±ìì—ì„œ getProjectList("Google")ë¥¼ í˜¸ì¶œí•˜ì—¬ Google GitHub í”„ë¡œì íŠ¸ë¥¼ ê²€ìƒ‰í•©ë‹ˆë‹¤.`

In real world cases, a transformation may be needed before passing the result data to the Observing
View, in order to make a transformation, you can use Transformation class as shown in the
documentation below:   
`ì‹¤ì œ ìƒí™©ì—ì„œëŠ” ê²°ê³¼ ë°ì´í„°ë¥¼ Observing Viewì— ì „ë‹¬í•˜ê¸° ì „ì— ë³€í™˜ì´ í•„ìš”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë³€í™˜ì„ ìˆ˜í–‰í•˜ë ¤ë©´ ì•„ë˜ ë¬¸ì„œì™€ ê°™ì´ Transformation í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`

## Sample App View Layer

`ìƒ˜í”Œ ì•±ì˜ ë·° ê³„ì¸µ`

Finally, letâ€™s give a quick look into the view layer of this app, we have mainly one Activity called
MainActivity which handles the navigation of two fragments that represent the app views:   
`ë§ˆì§€ë§‰ìœ¼ë¡œ ì´ ì•±ì˜ ë·° ë ˆì´ì–´ë¥¼ ê°„ëµíˆ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤. ì£¼ë¡œ MainActivityë¼ëŠ” ì•¡í‹°ë¹„í‹°ê°€ ìˆëŠ”ë° ì´ ì•¡í‹°ë¹„í‹°ëŠ” ì•± ë·°ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë‘ ê°œì˜ í”„ë˜ê·¸ë¨¼íŠ¸ íƒìƒ‰ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.`

1. ProjectListFragment, which displays the list of Google GitHub projects.   
   `ProjectListFragment, Google GitHub í”„ë¡œì íŠ¸ ëª©ë¡ì„ í‘œì‹œí•©ë‹ˆë‹¤.`

2. ProjectFragment, which displays the selected GitHub project details.   
   `ProjectFragment, ì„ íƒí•œ GitHub í”„ë¡œì íŠ¸ ì„¸ë¶€ ì •ë³´ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.`

Since Activities and Fragments are considered Life cycle owners, Activities need to extend
LifecycleActivity and fragments need to extend LifecycleFragment.   
`ì•¡í‹°ë¹„í‹°ì™€ í”„ë˜ê·¸ë¨¼íŠ¸ëŠ” ë¼ì´í”„ ì‚¬ì´í´ ì†Œìœ ìë¡œ ê°„ì£¼ë˜ë¯€ë¡œ ì•¡í‹°ë¹„í‹°ëŠ” LifecycleActivityë¥¼ í™•ì¥í•´ì•¼ í•˜ê³  í”„ë˜ê·¸ë¨¼íŠ¸ëŠ” LifecycleFragmentë¥¼ í™•ì¥í•´ì•¼ í•©ë‹ˆë‹¤.`

However, it is important to keep in mind that both LifecycleActivity and LifecycleFragment classes
are temporary implementations until Lifecycles are integrated with support library:   
`ê·¸ëŸ¬ë‚˜ LifecycleActivity ë° LifecycleFragment í´ë˜ìŠ¤ëŠ” ëª¨ë‘ Lifecycleì´ ì§€ì› ë¼ì´ë¸ŒëŸ¬ë¦¬ì™€ í†µí•©ë  ë•Œê¹Œì§€ ì„ì‹œ êµ¬í˜„ì´ë¼ëŠ” ì ì„ ëª…ì‹¬í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.`

Now, letâ€™s continue our projects retrieval scenario, looking into ProjectListFragment, the following
code snippet shows the most important integration part.   
`ì´ì œ í”„ë¡œì íŠ¸ ê²€ìƒ‰ ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ê³„ì† ì§„í–‰í•˜ì—¬ ProjectListFragmentë¥¼ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤. ë‹¤ìŒ ì½”ë“œ ìŠ¤ë‹ˆí«ì€ ê°€ì¥ ì¤‘ìš”í•œ í†µí•© ë¶€ë¶„ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.`

```
public class ProjectListFragment extends LifecycleFragment {
    private ProjectAdapter projectAdapter;
    
    //â€¦

    @Override
    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        final ProjectListViewModel viewModel =
                ViewModelProviders.of(this).get(ProjectListViewModel.class);

        observeViewModel(viewModel);
    }

    private void observeViewModel(ProjectListViewModel viewModel) {
        // Update the list when the data changes
        viewModel.getProjectListObservable().observe(this, new Observer<List<Project>>() {
            @Override
            public void onChanged(@Nullable List<Project> projects) {
                if (projects != null) {
                    //â€¦
                    projectAdapter.setProjectList(projects);
                }
            }
        });
    }

    //â€¦
}
```   

As shown above, ProjectListFragment gets ProjectListViewModel, and then listen to its
getProjectListObservable() method in order to get the list of Github projects when ready.    
`ìœ„ì™€ ê°™ì´ ProjectListFragmentëŠ” ProjectListViewModelì„ ê°€ì ¸ì˜¨ ë‹¤ìŒ getProjectListObservable() ë©”ì„œë“œë¥¼ ìˆ˜ì‹ í•˜ì—¬ ì¤€ë¹„ë˜ë©´ Github í”„ë¡œì íŠ¸ ëª©ë¡ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.`

Finally, Once the list of projects is retrieved, it is passed to projectAdapter (the RecyclerView
adapter)
in order to display the list of projects in the RecyclerView component.   
`ë§ˆì§€ë§‰ìœ¼ë¡œ í”„ë¡œì íŠ¸ ëª©ë¡ì´ ê²€ìƒ‰ë˜ë©´ RecyclerView êµ¬ì„± ìš”ì†Œì— í”„ë¡œì íŠ¸ ëª©ë¡ì„ í‘œì‹œí•˜ê¸° ìœ„í•´ projectAdapter(RecyclerView ì–´ëŒ‘í„°)ì— ì „ë‹¬ë©ë‹ˆë‹¤.`

This is the explanation of one end-to-end scenario of the project, you can find the complete project
available in GitHub here:   
`ì´ê²ƒì€ í”„ë¡œì íŠ¸ì˜ ì‹œë‚˜ë¦¬ì˜¤ì— ëŒ€í•œ ì„¤ëª…ì…ë‹ˆë‹¤. GitHubì—ì„œ ì‚¬ìš© ê°€ëŠ¥í•œ ì „ì²´ í”„ë¡œì íŠ¸ëŠ” ì—¬ê¸°ì—ì„œ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.`

[ìƒ˜í”Œë§í¬](https://github.com/hazems/mvvm-sample-app/tree/part1)

## Important Guiding Principles for MVVM Implementation

`MVVM êµ¬í˜„ì„ ìœ„í•œ ì¤‘ìš”í•œ ì§€ì¹¨ ì›ì¹™`

Now, it is important to highlight some of the important guiding principles for MVVM
implementation:   
`ì´ì œ MVVM êµ¬í˜„ì„ ìœ„í•œ ëª‡ ê°€ì§€ ì¤‘ìš”í•œ ì§€ì¹¨ ì›ì¹™ì„ ê°•ì¡°í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.`

1. As shown in the sample, ViewModels do not and must not reference Views directly because if this
   is done, ViewModels can outlive the Viewâ€™s lifecycle and memory leakage can happen.
   `ìƒ˜í”Œì— í‘œì‹œëœ ëŒ€ë¡œ ViewModelì€ Viewë¥¼ ì§ì ‘ ì°¸ì¡°í•˜ì§€ ì•Šìœ¼ë©° ì°¸ì¡°í•˜ì§€ ì•Šì•„ì•¼ í•©ë‹ˆë‹¤. 
   ViewModelì€ Viewì˜ ìˆ˜ëª… ì£¼ê¸°ë³´ë‹¤ ì˜¤ë˜ ì§€ì†ë  ìˆ˜ ìˆìœ¼ë©° ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`
   
2. Model and ViewModel are recommended to expose their data using LiveData since LiveData respects
   the lifecycle state of app components (activities, fragments, services) and handles object life
   cycle management which ensures that LiveData objects do not leak.
   `LiveDataëŠ” ì•± êµ¬ì„± ìš”ì†Œ(ì•¡í‹°ë¹„í‹°, í”„ë˜ê·¸ë¨¼íŠ¸, ì„œë¹„ìŠ¤)ì˜ ìˆ˜ëª… ì£¼ê¸° ìƒíƒœë¥¼ ì¡´ì¤‘í•˜ê³ 
   LiveData ê°œì²´ê°€ ëˆ„ì¶œë˜ì§€ ì•Šë„ë¡ ê°œì²´ ìˆ˜ëª… ì£¼ê¸° ê´€ë¦¬ë¥¼ ì²˜ë¦¬í•˜ë¯€ë¡œ Model ë° ViewModelì€ LiveDataë¥¼ ì‚¬ìš©í•˜ì—¬
   ë°ì´í„°ë¥¼ ë…¸ì¶œí•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.`
   