# ì˜ì–´ìŠ¤í„°ë”” ì‹œì¦Œ 5 8ì£¼ì°¨

created by [seungho](https://github.com/devaspirant0510) on 2022-03-27

[document link](https://proandroiddev.com/our-way-to-mvvmi-and-mistakes-we-made-when-implementing-mvvm-5f5448b5ad50)

# ğŸ“— ë‹¨ì–´ ì •ë¦¬ ğŸ“˜

|ì˜ì–´|í•œê¸€|
|----|----|
|stash|ìˆ¨ê¸°ë‹¤|
|stand point|ê´€ì |
|abort|ì¤‘ë‹¨ì‹œí‚¤ë‹¤|
|hold|ë³´ìœ í•˜ë‹¤|

Mistake 3: Not saving state onSaveInstanceState(), using only ViewModels to persist View state.  
`ì‹¤ìˆ˜ 3 : onSaveInstanceState() ëŠ” ìƒíƒœë¥¼ ì €ì¥í•˜ì§€ ì•ŠìŒ, ë‹¨ì§€ ë·°ëª¨ë¸ ì‚¬ìš©í•˜ì—¬ ë·° ìƒíƒœë¥¼ ìœ ì§€í•œë‹¤. `

ViewModels are designed to survive configuration changes and therefore, we can persist data and UI
state through configuration changes and no need to use onSaveInstanceState() any more.  
`ë·°ëª¨ë¸ì€ ë””ìì¸ë˜ì—ˆë‹¤. êµ¬ì„±ë³€ê²½ì— ì‚´ì•„ë‚¨ë„ë¡ ê·¸ëŸ¬ë¯€ë¡œ ìš°ë¦¬ëŠ” êµ¬ì„±ë³€ê²½ì„ í†µí•´ ë³€ê²½ë˜ëŠ” ë°ì´í„°ì™€ UI ìƒíƒœë¥¼ ìœ ì§€í• ìˆ˜ ìˆê³  ë”ì´ìƒ onSaveInstanceState()
ê°€ í•„ìš”í•˜ì§€ ì•Šë‹¤.`

That is what many assume.  
`ë§ì€ ì‚¬ëŒë“¤ì´ ê·¸ë ‡ê²Œ ìƒê°í•œë‹¤.`

But the reality is ViewModels can also be killed by OS in cases of low memory.  
`ê·¸ëŸ¬ë‚˜ í˜„ì‹¤ì€ ë·°ëª¨ë¸ì€ ë‹¨ì§€  ë©”ëª¨ë¦¬ê°€ ë¶€ì¡±í•œê²½ìš° OSì— ì˜í•´ ì£½ì„ìˆ˜ìˆë‹¤. `

Unlike saved instance state, ViewModels are destroyed during a system-initiated process death.   
`ì €ì¥ëœ ì¸ìŠ¤í„´ìŠ¤ ìƒíƒœì™€ ë‹¬ë¦¬, ë·°ëª¨ë¸ì€ ì‹œìŠ¤í…œì´ ì‹œì‘í•œ í”„ë¡œì„¸ìŠ¤ê°€ ì¢…ë£Œë˜ëŠ”ë™ì•ˆ íŒŒê´´ëœë‹¤.`

This is why you should use ViewModel objects in combination with onSaveInstanceState() (or some other disk persistence),
stashing identifiers in savedInstanceState to help view models reload the data after system death.   
`ì´ê²ƒì´ ë„ˆê°€ ë·°ëª¨ë¸ ê°ì²´ë¥¼  onSaveInstanceState()(ë˜ëŠ” ë‹¤ë¥¸ ì§€ì†ì ì¸ ì €ì¥) ì™€ í•¨ê»˜ ì‚¬ìš©í•´ì•¼ë˜ëŠ” ì´ìœ ì´ê³ , ì‹œìŠ¤í…œ ì¢…ë£Œ í›„ ë·° ëª¨ë¸ì´ ë°ì´í„°ë¥¼ ë‹¤ì‹œ 
ë¡œë“œí•˜ëŠ” ë° ë„ì›€ì´ ë˜ë„ë¡ storedInstanceStateì— ì‹ë³„ìë¥¼ ìˆ¨ê¹ë‹ˆë‹¤. `

Android docs contain more information on persisting state.  
`ì•ˆë“œë¡œì´ë“œ ë¬¸ì„œì—ì„œ í¬í•¨í•©ë‹ˆë‹¤. ì§€ì†ì ì€ ë°ì´í„°ì—ëŒ€í•œ ì •ë³´ë¥¼ `

![image](https://user-images.githubusercontent.com/68223593/159128431-a38834b2-c297-48b9-acfe-4421a1b9a8a7.png)
[SavedStateHandleê³¼ í•¨ê»˜ ViewModelì˜ ìƒíƒœë¥¼ ì €ì¥í•˜ì](https://charlezz.medium.com/ui-%EC%83%81%ED%83%9C-%EC%A0%80%EC%9E%A5-%EB%B0%8F-%EB%B3%B5%EC%9B%90%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1-a00297e7a20b)


Solution: Calling onSaveInstanceState() should work along side with ViewModel and LiveData lifecycle management benefits.  
`í•´ê²°ë²• : onSaveInstanceState() í˜¸ì¶œì€ ViewModel ë° LiveData ìˆ˜ëª… ì£¼ê¸° ê´€ë¦¬ì™€ í•¨ê»˜ ì‘ë™í•´ì•¼ í•©ë‹ˆë‹¤.`
Advantages: Improved UX as data and UI state is persisted.  
`ì¥ì  : ë°ì´í„° ë° UI ìƒíƒœê°€ ìœ ì§€ë¨ì— ë”°ë¼ UXê°€ ê°œì„ ë˜ì—ˆìŠµë‹ˆë‹¤`
The number of possible bugs is reduced as View behaves as expected.  
`Viewê°€ ì˜ˆìƒëŒ€ë¡œ ì‘ë™í•˜ë¯€ë¡œ ê°€ëŠ¥í•œ ë²„ê·¸ì˜ ìˆ˜ê°€ ì¤„ì–´ë“­ë‹ˆë‹¤.`

Mistake 4: Not dropping Repository callbacks when View is destroyed.  
`ì‹¤ìˆ˜ 4 : ë·°ê°€ íŒŒê´´ë ë•Œ ë ˆíŒŒì§€í† ë¦¬ë¥¼ ì‚­ì œí•˜ì§€ ì•Šì•˜ë‹¤.`

If View is destroyed, ViewModel is not observed anymore.  
`ë§Œì•½ ë·°ê°€ íŒŒê´´ë¬ìœ¼ë©´ ë·°ëª¨ë¸ì€ ë”ì´ìƒ ê´€ì°°í•˜ë©´ ì•ˆë©ë‹ˆë‹¤.`

Thus, from the memory management stand point it should be GC.  
`ê·¸ë¡œë¯€ë¡œ, ë©”ëª¨ë¦¬ê´€ì ì—ì„œ GC ì—¬ì•¼ í•©ë‹ˆë‹¤.`

However if Repository holds a reference to ViewModel through observable types or callbacks, 
then ViewModel will be retained aka leaked.  
`ê·¸ëŸ¬ë‚˜ Repositoryê°€ ê´€ì°° ê°€ëŠ¥í•œ ìœ í˜•ì´ë‚˜ ì½œë°±ì„ í†µí•´ ViewModelì— ëŒ€í•œ ì°¸ì¡°ë¥¼ ë³´ìœ í•˜ëŠ” ê²½ìš° ViewModelì€ ëˆ„ì¶œ(leaked)ë¡œ ìœ ì§€ë©ë‹ˆë‹¤.`

Solution: When onCleared() is called for a ViewModel object all network operations should be aborted,
observers unsubscribed and callbacks dropped.  
`í•´ê²°ì±… :  onCleared() ê°€ ë·°ëª¨ë¸ ê°ì²´ë¡œë¶€í„° í˜¸ì¶œë ë•Œ ëª¨ë“  ë„¤íŠ¸ì›Œí¬ ì—°ì‚°ì€ ì¤‘ë‹¨ì‹œí‚¤ê³ , ì˜µì €ë²„ëŠ” êµ¬ë… ì·¨ì†Œí•˜ê³  ì½œë°±ì€ ì‚­ì œí•œë‹¤.`

Advantages: Remove the risk of leaking ViewModel.  
`ì¥ì  : ë·°ëª¨ë¸ì—ì„œ ëˆ„ì¶œìœ„í—˜ì„ ì œê±°í•œë‹¤.`

Mistake 5: Pulling data from ViewModel toView.  
`ì‹¤ìˆ˜ 5 : ë·°ëª¨ë¸ì—ì„œ Viewë¡œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°`

This pattern of calling ViewModel methods partially came from developers being more familiar with MVP so 
the old habits were applied to the â€œnewâ€ pattern.   
`ì´ ë·°ëª¨ë¸ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ëŠ” ì´ íŒ¨í„´ì€ ë¶€ë¶„ì ìœ¼ë¡œ ê°œë°œìê°€ MVP ì— ë” ìµìˆ™í•˜ê¸° ë–„ë¬¸ì— "ìƒˆë¡œìš´" íŒ¨í„´ì— ì˜¤ë˜ëœ ìŠµê´€ì´ ì ìš©ë¬ìŠµë‹ˆë‹¤. `

The purpose of the View is to observe and react on commands being posted from ViewModel.  
`ë·°ì˜ ëª©ì ì€ ê´€ì°°ë˜ê³  ë·°ëª¨ë¸ë¡œë¶€í„° ì‘ì„±ëœ ì»¤ë§¨ë“œì— ë°˜ì‘í•©ë‹ˆë‹¤.`

Adding some code snippets to better illustrate what kind of â€œreferring ViewModelâ€ I find bad practice.  
`ì½”ë“œ ìŠ¤ë‹ˆí«ì„ ì¶”ê°€í•˜ì—¬ ì–´ë–¤ ì¢…ë¥˜ì˜ View Modelì„ ì°¸ì¡°í•˜ê³  ìˆëŠ”ì§€ í™•ì¸í•˜ë©´ ì¢‹ì§€ ì•Šì€ ë°©ë²•ì„ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.`

The code as in the example below shouldnâ€™t be in your View for several reasons.  
`ì˜ˆì‹œì™€ ê°™ì€ ì•„ë˜ ì½”ë“œëŠ” ë„ˆì˜ ë·°ì—ì„œ ëª‡ê°œì˜ ì˜¤ë¥˜ë¡œ ì¸í•´ ë·°ì— í‘œì‹œë˜ë©´  ì•ˆë©ë‹ˆë‹¤.`

Firstly, you are bringing logic into View.  
`ì²«ì§¸ë¡œ ë„ˆëŠ” view ì—ì„œ ë¡œì§ì„ ê°€ì ¸ì™€ì•¼ë©ë‹ˆë‹¤.`

If you see an if condition with the reference to ViewModel that means you are pulling the presentation logic into View.  
`ViewModelì— ëŒ€í•œ ì°¸ì¡°ê°€ ìˆëŠ” ì¡°ê±´ì´ í‘œì‹œë˜ëŠ” ê²½ìš° í”„ë ˆì  í…Œì´ì…˜ ë¡œì§ì„ Viewë¡œ ëŒì–´ì˜¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.`

Now we will have to test logic in View alsoâ€¦doesnâ€™t sound good.  
`ì´ì œ ìš°ë¦¬ëŠ” ë·°ì—ì„œë„ ë¡œì§ì„ í…ŒìŠ¤íŠ¸í•´ì•¼í•©ë‹ˆë‹¤. ì¢‹ì§€ì•ŠìŠµë‹ˆë‹¤.`

Keep your View dumb! 
Secondly, this clashes with the observer pattern MVVM+LiveData+DataBinding will bring into your project.  
`ë‘˜ì§¸, ì´ê²ƒì€ MVVM+LiveData+DataBindingì´ í”„ë¡œì íŠ¸ì— ê°€ì ¸ì˜¬ ê´€ì°°ì íŒ¨í„´ê³¼ ì¶©ëŒí•©ë‹ˆë‹¤.`

You should expose and push events.   
`ë„ˆëŠ” ì´ë²¤íŠ¸ë¥¼ ë…¸ì¶œí•˜ê³  í‘¸ì‹œí•´ì•¼í•©ë‹ˆë‹¤.`
Donâ€™t let View query the state.  
`ë·°ê°€ ìƒíƒœë¥¼ ì¿¼ë¦¬í•˜ë„ë¡ í•˜ì§€ ë§ˆì‹­ì‹œì˜¤`

```kotlin
if (viewModel.isUserTeacher()) { //pulling info from ViewModel to View -> not cool
    showTeacherGreeting()       
} else {                          
    showStudentGreeting()
}
```
The alternative to that piece would be something like this put in ViewModel.  
`ê·¸ ì¡°ê°ì— ëŒ€í•œ ëŒ€ì•ˆì€ ViewModelì— ë‹¤ìŒê³¼ ê°™ì€ ê²ƒì´ ë  ê²ƒì…ë‹ˆë‹¤.`
```kotlin
if (isUserTeacher()) {
    eventLiveData.postValue(SHOW_TEACHER_GREETING) //LiveData object View is subscribed to
} else {
    eventLiveData.postValue(SHOW_STUDENT_GREETING)
}
```
Nevertheless, there is nothing wrong with calling ViewModel to load data upon creation of your View for example,
just keep in mind that if you start seeing if-blocks in your View and multiple calls to ViewModel, 
you need to reevaluate your design.  
`ê·¸ëŸ¼ì—ë„ ë¶ˆêµ¬í•˜ê³ , ì˜ˆë¥¼ ë“¤ì–´ View ìƒì„± ì‹œ ë°ì´í„°ë¥¼ ë¡œë“œí•˜ê¸° ìœ„í•´ ViewModelì„ í˜¸ì¶œí•˜ëŠ” ë°ì—ëŠ” ì•„ë¬´ëŸ° ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤. 
Viewì—ì„œ if ë¸”ë¡ì´ í‘œì‹œë˜ê³  ViewModelì— ëŒ€í•œ ì—¬ëŸ¬ í˜¸ì¶œì´ í‘œì‹œë˜ê¸° ì‹œì‘í•˜ë©´ ë””ìì¸ì„ ì¬í‰ê°€í•´ì•¼ í•©ë‹ˆë‹¤`



Solution: Create a LiveData object to which ViewModel will post command events observed by View.  
`ViewModelì´ Viewì—ì„œ ê´€ì°°í•œ ëª…ë ¹ ì´ë²¤íŠ¸ë¥¼ ê²Œì‹œí•  LiveData ê°œì²´ë¥¼ ë§Œë“­ë‹ˆë‹¤.`

ViewModel will push commands to View instead of View querying ViewModel for state and flags.  
`ViewModelì€ ìƒíƒœ ë° í”Œë˜ê·¸ì— ëŒ€í•´ ViewModelì„ ì¿¼ë¦¬í•˜ëŠ” View ëŒ€ì‹  Viewì— ëª…ë ¹ì„ í‘¸ì‹œí•©ë‹ˆë‹¤.`


Advantages: This approach gives you the advantage of testability and decoupling and prevents View from querying 
ViewModel for state or invoking methods inside ViewModel which supports the idea of dumb testable View.  
`ê·¸ì˜ ì ‘ê·¼ ë°©ì‹ì€ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„±ê³¼ ë¶„ë¦¬ì˜ ì´ì ì„ ì œê³µí•˜ê³  Viewê°€ ViewModelì— ìƒíƒœë¥¼ ì¿¼ë¦¬í•˜ê±°ë‚˜ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•œ Dumbì˜ ì•„ì´ë””ì–´ë¥¼ ì§€ì›í•˜ëŠ”
ViewModel ë‚´ë¶€ì˜ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ëŠ” ê²ƒì„ ë°©ì§€í•©ë‹ˆë‹¤.`

Ideally View will only contain subscriptions to LiveData.  
`ì´ìƒì ìœ¼ë¡œ ë³´ê¸°ì—ëŠ” LiveDataì— ëŒ€í•œ êµ¬ë…ë§Œ í¬í•¨ë©ë‹ˆë‹¤.`

Final Thoughts
MVVM pattern provides a lot of advantages tied to the use of Architecture Components.   
`MVVM íŒ¨í„´ì€ ì•„í‚¤í…ì³ ì»´í¬ë„ŒíŠ¸ì™€ ê´€ë ¨ëœ ë§ì€ ì¥ì ì„ ì œê³µí•©ë‹ˆë‹¤.`

Compared to MVP it can significantly decrease logic contained in View.   
`MVP ì™€ ë¹„êµí• ë•Œ ê·¸ê²ƒì€ ë·°ì—ì„œ ìƒë‹¹í•˜ê²Œ ë¡œì§ì„ ì¤„ì¼ìˆ˜ìˆìŠµë‹ˆë‹¤.`

However, any newer pattern needs some time for trial and error and finding the best approach in your project.    
`ê·¸ëŸ¬ë‚˜ ì–´ëŠ ìƒˆë¡œìš´ íŒ¨í„´ì€ ì‹œí–‰ì°©ì˜¤ì™€ ì—ëŸ¬ ë„ˆì˜ í”„ë¡œì íŠ¸ì—ì„œ ìµœê³ ì˜ ì ‘ê·¼ë°©ë²•ì„ ì°¾ëŠ”ëŒ€ ì•½ê°„ì˜ ì‹œê°„ì´ í•„ìš”í•©ë‹ˆë‹¤.`

Avoid those mistakes that we made to avoid the headache of refactoring of your freshly created project.  
`ìƒˆë¡œ ìƒì„±ëœ í”„ë¡œì íŠ¸ë¥¼ ë¦¬íŒ©í† ë§í•˜ëŠ” ë²ˆê±°ë¡œì›€ì„ í”¼í•˜ê¸° ìœ„í•´ ìš°ë¦¬ê°€ ì €ì§€ë¥¸ ì‹¤ìˆ˜ë¥¼ í”¼í•˜ì‹­ì‹œì˜¤.`