# ì˜ì–´ìŠ¤í„°ë”” ì‹œì¦Œ 5 1ì£¼ì°¨

created by [juho](https://github.com/pachuho/Development-English-study) on 2022-02-27

[MVVM Architecture & LiveData, ViewModel, LifeCycle Components](https://medium.com/android-news/android-architecture-pattern-components-mvvm-livedata-viewmodel-lifecycle-544e84e85177)

# ğŸ“— ë‹¨ì–´ ì •ë¦¬ ğŸ“˜

### OBS BUILD
|ì˜ì–´|í•œê¸€|
|---|---|
|come up with|ì°¾ì•„ë‚´ë‹¤, ë‚´ë†“ë‹¤| 
|brief|ì§§ì€, ì ê¹ ë™ì•ˆì˜, ê°„ë‹¨í•œ|
|consolidate|í†µí•©í•˜ë‹¤|
|in the middle of|ë„ì¤‘ì—|

------------------------------

# MVVM Architecture & LiveData, ViewModel, LifeCycle Components

MVC, MVP and MVVM are some of the Architecture patterns used by developers around the world. Which one to use, 
depends upon the requirement and how comfortable is one with the architecture pattern. 

`MVC, MVP ê·¸ë¦¬ê³  MVVMì€ ì „ì„¸ê³„ ê°œë°œìë“¤ì´ ì‚¬ìš©í•˜ëŠ” ì•„í‚¤í…ì²˜ íŒ¨í„´ì˜ ì¼ë¶€ì…ë‹ˆë‹¤. ì–´ëŠê²ƒì„ ì‚¬ìš©í•˜ëŠ”ì§€ëŠ” ìš”êµ¬ì‚¬í•­ê³¼ ì–´ë–¤ê²Œ í¸í•œì§€ì— ë”°ë¼ ê²°ì •ë©ë‹ˆë‹¤.`

However you should try to use one, it helps to keep the code segregated, modularised, readable, decoupled and easier to test.

`ê·¸ëŸ¬ë‚˜ ê·¸ì¤‘ í•˜ë‚˜ë¥¼ ì‚¬ìš©í•œë‹¤ë©´ ê·¸ íŒ¨í„´ì€ ì½”ë“œë¥¼ ì„¸ë¶„ê³¼ ëª¨ë“ˆí™” ì½ê¸° ë¶„ë¦¬ ê·¸ë¦¬ê³  ì‰½ê²Œ í…ŒìŠ¤íŠ¸ í•˜ëŠ”ê±¸ ë„ì™€ì¤ë‹ˆë‹¤.`

Since the android development started Google never came up with their own architecture until recently. 

`ì•ˆë“œë¡œì´ë“œ ê°œë°œì„ ì‹œì‘í•˜ê³  êµ¬ê¸€ì€ ìµœê·¼ê¹Œì§€ ìì²´ ì•„í‚¤í…ì²˜ë¥¼ ë‚´ë†“ì§€ ì•Šì•˜ë‹¤`

Google has introduced android architecture components which includes Life cycles, ViewModel, Room and LiveData.

`êµ¬ê¸€ì€ ë¼ì´í”„ì‚¬ì´í´, ë·°ëª¨ë¸, ë£¸ ê·¸ë¦­ ë¼ì´ë¸Œë°ì´í„°ë¥¼ í¬í•¨í•˜ëŠ” ì•ˆë“œë¡œì´ë“œ ì•„í‚¤í…ì²˜ ì»´í¬ë„ŒíŠ¸ë¥¼ ë„ì…í–ˆìŠµë‹ˆë‹¤.`

## Why am I here

This Article will provide brief of MVVM Architecture, LiveData, ViewModel and Lifecycle components.

`ì´ ê¸°ì‚¬ì—ì„  mvvm ì•„í‚¤í…ì²˜, ë¼ì´ë¸Œë°ì´í„°, ë·°ëª¨ë¸ ê·¸ë¦¬ê³  ë¼ì´í”„ì‚¬ì´í´ ì»´í¬ë„ŒíŠ¸ì— ëŒ€í•´ ê°„ë‹¨í•˜ê²Œ ì„¤ëª…í• ê²ë‹ˆë‹¤.`


## Letâ€™s get started

Before we start, I would recommend you to download a project from here.
This Application displays list of news in a Recycler view and on click of any news item, detailed news will be opened in a WebView. 

`ì‹œì‘ì „ í”„ë¡œì íŠ¸ë¥¼ ë‹¤ìš´ë°›ê¸°ë¥¼ ì¶”ì²œí•©ë‹ˆë‹¤. ì´ ì–´í”Œë¦¬ì¼€ì´ì…˜ì€ ë‰´ìŠ¤ ì•„ì´í…œì„ í´ë¦­í•˜ê³  ë¦¬ì‚¬ì´í´ëŸ¬ë·°ì— ìˆëŠ” ë‰´ìŠ¤ ë¦¬ìŠ¤íŠ¸ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤. ì„¸ë¶€ì ìœ¼ë¡œ ë‰´ìŠ¤ëŠ” ì›¹ë·°ì—ì„œ ì—´ë¦½ë‹ˆë‹¤.`

You can also refer screenshots from here. As we go through the article,
we will be using pieces of code from this project to understand architecture pattern and components.

`ìŠ¤í¬ë¦°ìƒ·ì„ ì—¬ê¸°ì—ì„œ ì•Œì•„ë³¼ ìˆ˜ ìˆë‹¤. ìš°ë¦¬ì˜ ì•„í‹°í´ì„ í†µí•´ ìš°ë¦¬ëŠ” ì•„í‚¤í…ì²˜ íŒ¨í„´ê³¼ ì»´í¬ë„ŒíŠ¸ë¥¼ ì´í•´í•˜ê¸°ìœ„í•´ì„œ ìš°ë¦¬ í”„ë¡œì íŠ¸ë¡œë¶€í„° ì¼ë¶€ ì½”ë“œë¥¼ ì‚¬ìš©í•  ê²ƒì…ë‹ˆë‹¤.`

## Downloaded, Good to Go ğŸ‘ğŸ»

So Finally there is an architecture(MVVM) which follows the Single Responsibility Principle. 
Each component does single and unique Job, which is why it is recommended to write as many component classes as many needed. 
Before moving to MVVM Letâ€™s understand Android components.

`ìµœì¢…ì ìœ¼ë¡œ mvvmì€ ë‹¨ì¼ ì±…ì„ ì›ì¹™ì„ ë”°ë¦…ë‹ˆë‹¤. ê° ì»´í¬ë„ŒíŠ¸ëŠ” ë‹¨ì¼ì´ê³  ìœ ì¼í•œ ì‘ì—…ì„ ìˆ˜í–‰í•˜ë¯€ë¡œ í•„ìš”í•œ ìˆ˜ë§Œí¼ ë§ì€ ì»´í¬ë„ŒíŠ¸ í´ë˜ìŠ¤ë¥¼ ì‘ì„±í•˜ëŠ”ê²ƒì„ ì¶”ì²œí•©ë‹ˆë‹¤. mvvmìœ¼ë¡œ ì´ë™í•˜ê¸° ì „ì— ì•ˆë“œë¡œì´ë“œ ì»´í¬ë„ŒíŠ¸ë¥¼ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤.`

## We will start with LiveData

LiveData is an observable holder class. It is like any other observer which implements Observer class, 
but LiveData is also linked with component (activity/Fragment/Service) life cycle. 

`ë¼ì´ë¸Œë°ì´í„°ëŠ” ê´€ì°°ê°€ëŠ¥í•œ í™€ë” í´ë˜ìŠ¤ì…ë‹ˆë‹¤. ì˜µì €ë²„ í´ë˜ìŠ¤ë¥¼ êµ¬í˜„í•˜ëŠ” ë‹¤ë¥¸ ì˜µì €ë²„ì™€ ë¹„ìŠ·í•˜ì§€ë§Œ ë¼ì´ë¸Œë°ì´í„°ëŠ” ì»´í¬ë„ŒíŠ¸ ë¼ì´í”„ ì‚¬ì´í´ì— ì—°ê²°ë˜ì–´ ìˆìŠµë‹ˆë‹¤.`

In case a component is destroyed, it will automatically stop observing the changes and 
release unused allocated memory which would help in avoiding memory leaks.

`ì»´í¬ë„ŒíŠ¸ê°€ íŒŒê´´ë˜ëŠ” ê²½ìš° ìë™ìœ¼ë¡œ ì˜µì €ë¹™ì„ ë©ˆì¶”ê³  ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ë¥¼ ë°©ì§€í•˜ê¸°ìœ„í•´ ë„ì›€ì´ë˜ëŠ” ë©”ëª¨ë¦¬ í• ë‹¹ ì‚¬ìš©ì„ í•´ì œí•©ë‹ˆë‹¤.`

Using LiveData you consolidate your UI since observer would be triggering the UI changes if there is any change in data properties. 
We can wrap around an object to LiveData and start listening for data changes.

`ë¼ì´ë¸Œë°ì´í„°ëŠ” ì˜µì €ë²„ê°€ ë°ì´í„° ì†ì„±ì´ ë³€ê²½ë˜ë©´ uië³€í™”ë¥¼ íŠ¸ë¦¬ê±°í•˜ê³  ìˆê¸°ë•Œë¬¸ì— uië¥¼ í†µí•©í•©ë‹ˆë‹¤. ìš°ë¦¬ëŠ” ê°ì²´ë¥¼ ë¼ì´ë¸Œë°ì´í„°ì— ë˜í•‘í•  ìˆ˜ ìˆê³  ë°ì´í„° ë³€í™”ë¥¼ ìˆ˜ì‹ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`

```kotlin
// setting value
public LiveData<News> getNews(String source) {
    final MutableLiveData<News> data = new MutableLiveData<>();
    getNews(source).enqueue(new Callback<News>() {
        @Override
        public void onResponse(Call<News> call, Response<News> response) {
            data.setValue(response.body());
        }

        @Override
        public void onFailure(Call<News> call, Throwable t) {
            data.setValue(null);
        }
    });
    return data;
}
//listening for change in <Object>. // this would be in ui layer
getObservableProject().observe(this, new Observer<Object>() {
    @Override
    public void onChanged(@Nullable Object obj) {
       // handle changes
    }
});
```

In the Above Example News object is being fetched by an api call and is wrapped inside LiveData. 
UI layer observes LiveData object changes. 

`ìœ„ ì˜ˆì œì—ì„œ ë‰´ìŠ¤ ê°ì²´ëŠ” apií˜¸ì¶œì— ì˜í•´ íŒ¨ì¹˜ë˜ê³  ë¼ì´ë¸Œë°ì´í„° ì•ˆì— ë˜í•‘ë©ë‹ˆë‹¤. uië ˆì´ì–´ëŠ” ë¼ì´ë¸Œë°ì´í„° ê°ì²´ ë³€í™”ë¥¼ ê´€ì°°í•©ë‹ˆë‹¤.`

So on change of object properties, UI would be changed automatically. 
Also, it will save us the trouble of handling cases such as 
what happens if user kills activity in the middle of API call since it will stop listening to the changes as soon as activity is destroyed.

`ë”°ë¼ì„œ ê°ì²´ ì†ì„±ì´ ë³€ê²½ë˜ë©´ uiëŠ” ìë™ìœ¼ë¡œ ë³€ê²½ë©ë‹ˆë‹¤. ë˜í•œ ì•¡í‹°ë¹„í‹°ê°€ íŒŒê´´ë˜ìë§ˆì ë³€ê²½ì— ëŒ€í•œ ë¦¬ìŠ¤ë‹ì„ ë©ˆì¶”ê¸° ë•Œë¬¸ì— apií˜¸ì¶œ ë„ì¤‘ì— ì‚¬ìš©ìê°€ ì•¡í‹°ë¹„í‹°ë¥¼ ì¢…ë£Œ ê²½ìš°ì™€ ê°™ì€ ì¼€ì´ìŠ¤ë“¤ì„ ì²˜ë¦¬ë¥¼ ë³´í˜¸í•´ì¤ë‹ˆë‹¤.`

## ViewModel

If you use a ViewModel, you would not have to worry about saving the data on configuration changes. 

`ë·°ëª¨ë¸ì„ ì‚¬ìš©í•œë‹¤ë©´ êµ¬ì„±ë³€í™”ì— ë°ì´í„° ì €ì¥ì— ëŒ€í•œ ì €ì¥ì„ ê±±ì •í•˜ì§€ ì•Šì•„ë„ ë©ë‹ˆë‹¤.`

In general, on configuration change activity is recreated and so does every other data retrieval. 

`ì¼ë°˜ì ìœ¼ë¡œ ì•¡í‹°ë¹„í‹° êµ¬ì„±ë³€í™”ëŠ” ìƒˆë¡œ ìƒì„±ë˜ê³  ë‹¤ë¥¸ ëª¨ë“  ë°ì´í„° ê²€ìƒ‰ë„ ë§ˆì°¬ê°€ì§€ì…ë‹ˆë‹¤.`

It can be an API call, db call or any other data related operation. 
ViewModel saves us all this trouble and keep the data alive until component is killed.

`api í˜¸ì¶¢ dbí˜¸ì¶œ ë‹¤ë¥¸ ë°ì´í„° ê´€ë ¨ ì—°ì‚°ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë·°ëª¨ë¸ì€ ìš°ë¦¬ê°€ ëª¨ë“  ì´ëŸ° ë¬¸ì œì ê³¼ ë°ì´í„°ë¥¼ ì»´í¬ë„ŒíŠ¸ê°€ ì£½ê¸°ì „ê¹Œì§€ ìœ ì§€í•˜ëŠ”ê±¸ í•´ê²°í•©ë‹ˆë‹¤.`

Letâ€™s say we have an activity which displays result based upon searched query. 
Activity gets search query text from another component and then makes an API call to display results. 

`ìš°ë¦¬ëŠ” ê²€ìƒ‰ ì¿¼ë¦¬ ê²°ê³¼ë¥¼ ë³´ì—¬ì£¼ëŠ” ì•¡í‹°ë¹„í‹°ê°€ ìˆë‹¤ê³  ê°€ì •í•©ì‹œë‹¤. ì•¡í‹°ë¹„í‹°ëŠ” ë‹¤ë¥¸ ì»´í¬ë„ŒíŠ¸ë¡œë¶€í„° ê²€ìƒ‰ ì¿¼ë¦¬ í…ìŠ¤íŠ¸ë¥¼ ê°€ì ¸ì˜¤ê³  apië¥¼ í˜¸ì¶œí•˜ì—¬ ê²°ê³¼ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.`

In this case if user rotates device, there would be repetitive API call. 
If a ViewModel is used for any such cases then data would be saved automatically. 
ViewModel objects are automatically retained on configuration changes.

`ì´ ê²½ìš° ì‚¬ìš©ìê°€ ë””ë°”ì´ìŠ¤ë¥¼ íšŒì „ì‹œí‚¨ë‹¤ë©´ apií˜¸ì¶œì´ ë°˜ë³µë©ë‹ˆë‹¤. ë§Œì•½ ì´ëŸ°ê²½ìš° ë·°ëª¨ë¸ì„ ì‚¬ìš©í•œë‹¤ë©´ ë°ì´í„°ëŠ” ìë™ìœ¼ë¡œ ì €ì¥ë©ë‹ˆë‹¤. ë·°ëª¨ë¸ ê°ì²´ëŠ” ìë™ìœ¼ë¡œ êµ¬ì„±ìš”ì†Œ ë³€ê²½ì— ëŒ€í•´ ìœ ì§€ë©ë‹ˆë‹¤.`

ViewModel objects are attached to component life cycle and only gets away when the component is destroyed. 
In case of Activity it would be in onDestroy() and in case of Fragment it would be in onDetach().

`ë·°ëª¨ë¸ê°ì²´ëŠ” ì»´í¬ë„ŒíŠ¸ ë¼ì´í”„ì‚¬ì´í´ì— ë¶€ì°©ë˜ê³  ì˜¤ì§ ì»´í¬ë„ŒíŠ¸ê°€ íŒŒê´´ë  ë•Œ ì‚¬ë¼ì§‘ë‹ˆë‹¤. ì•¡í‹°ë¹„í‹°ì˜ ê²½ìš° onDestroy()ì™€ í”„ë˜ê·¸ë¨¼íŠ¸ì˜ ê²½ìš° onDetach()ê°€ ìˆìŠµë‹ˆë‹¤.`

```kotlin
// View model for News Object
public class NewsViewModel extends AndroidViewModel {
    private final LiveData<News> newsLiveData;

    public ObservableField<News> news = new ObservableField<>();

    public NewsViewModel(@NonNull Application application) {
        super(application);
        // a differnt source can be passed, here i am passing techcrunch
        newsLiveData = NewsRepository.getInstance().getNews("techcrunch");
    }

    public LiveData<News> getObservableProject() {
        return newsLiveData;
    }
}
// accessing NewsModel Object
final NewsViewModel viewModel = ViewModelProviders.of(this, factory)
        .get(NewsViewModel.class);
viewModel.getObservableProject().observe(this, new Observer<News>() {
    @Override
    public void onChanged(@Nullable News news) {
      // 
    }
});
```