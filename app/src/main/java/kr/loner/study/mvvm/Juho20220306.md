# ì˜ì–´ìŠ¤í„°ë”” ì‹œì¦Œ 5 6ì£¼ì°¨

created by [juho](https://github.com/pachuho/Development-English-study) on 2022-03-06

[MVVM Architecture & LiveData, ViewModel, LifeCycle Components](https://medium.com/android-news/android-architecture-pattern-components-mvvm-livedata-viewmodel-lifecycle-544e84e85177)

# ğŸ“— ë‹¨ì–´ ì •ë¦¬ ğŸ“˜

### OBS BUILD
|ì˜ì–´|í•œê¸€|
|---|---|
|cumbersome|ë²ˆê±°ë¡œìš´, ë‹¤ë£¨ê¸° í˜ë“ |

------------------------------

In the example, News object is wrapped inside NewsViewModel and same is used for observing data inside fragment.

`ì´ ì˜ˆì œì—ì„œ ë‰´ìŠ¤ ê°ì²´ëŠ” ìƒˆë·°ëª¨ë¸ ë‚´ë¶€ì— ë˜í•‘ë˜ì–´ìˆê³  í”„ë˜ê·¸ë¨¼íŠ¸ ë‚´ë¶€ì— ë°ì´í„°ë¥¼ ì˜µì €ë¹™í•˜ê¸°ìœ„í•´ ì‚¬ìš©ë©ë‹ˆë‹¤.`

Also, You should avoid keeping references of views in ViewModel, 
that might lead memory leaks since ViewModel does not get destroyed on configuration changes.

`ë˜í•œ êµ¬ì„± ë³€í™”ì— íŒŒê´´ë˜ì§€ ì•ŠëŠ” ë·°ëª¨ë¸ë•Œë¬¸ì— ë©”ëª¨ë¦¬ë¦­ì´ ë°œìƒí•˜ëŠ” ë·°ëª¨ë¸ì•ˆì— ë·°ë“¤ì˜ ë ˆí¼ëŸ°ìŠ¤ë“¤ì´ ìœ ì§€ë˜ëŠ”ê±¸ í”¼í•´ì•¼í•©ë‹ˆë‹¤.`

However ViewModel wonâ€™t be retained on back press, if application is removed from recent or if system kills the activity. 
In such cases onSaveInstance method has to be implemented to retain the needed data.

`ê·¸ëŸ¬ë‚˜ ì•±ì´ ìµœê·¼ ì œê±°ë˜ê±°ë‚˜ ì‹œìŠ¤í…œì´ ì•¡í‹°ë¹„í‹°ë¥¼ ì œê±°í•˜ëŠ” ê²½ìš° ë·°ëª¨ë¸ì€ ë°±í”„ë ˆìŠ¤ì— í¬í•¨ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì´ëŸ° ê²½ìš° onSaveInstanceë¥¼ ì‚¬ìš©í•´ì„œ í•„ìš”í•œ ë°ì´í„°ë¥¼ ìœ ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`

Apart from this You can share data between two fragments using ViewModel. 
It can be done something like this.

`ì´ ì™¸ì—ë„ ë·°ëª¨ë¸ì„ ì‚¬ìš©í•˜ì—¬ ë‘ í”„ë˜ê·¸ë¨¼íŠ¸ ì‚¬ì´ì— ë°ì´í„°ë¥¼ ê³µìœ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŸ°ì‹ìœ¼ë¡œ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`

```kotlin
public class SharedViewModel extends ViewModel {
    private final MutableLiveData<Item> selected = new MutableLiveData<Item>();

    public void select(Item item) {
        selected.setValue(item);
    }

    public LiveData<Item> getSelected() {
        return selected;
    }
}

public class MasterFragment extends Fragment {
    private SharedViewModel model;
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class);
        itemSelector.setOnClickListener(item -> {
            model.select(item);
        });
    }
}

public class DetailFragment extends Fragment {
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        SharedViewModel model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class);
        model.getSelected().observe(this, { item ->
           // Update the UI.
        });
    }
}
```

Off course, You can do it using interfaces but that is a cumbersome way to handle communication. 
If you use ViewModel, Activity and Fragment would not have any clue of communication. 

`ë¬¼ë¡  ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆì§€ë§Œ ê·¸ê±´ í†µì‹ ì„ ë‹¤ë£¨ê¸°ì—ëŠ” ë²ˆê±°ë¡œìš´ ë°©ë²•ì…ë‹ˆë‹¤. ë·°ëª¨ë¸ì„ ì‚¬ìš©í•œë‹¤ë©´ ì•¡í‹°ë¹„í‹°ì™€ í”„ë˜ê·¸ë¨¼íŠ¸ëŠ” ì–´ë– í•œ í†µì‹ ì— ëŒ€í•œ ë‹¨ì„œê°€ ì—†ìŠµë‹ˆë‹¤.`

They will be communicating through SharedViewModel. You can read more about it from here.

`ì‰ì–´ë“œë·°ëª¨ë¸ì„ í†µí•´ í†µì‹ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`

## Handling Life Cycle

This Architecture components comes with LifeCycle Observer. 
As name suggests you can create an observer which will bind to a componentâ€™s lifecycle.

`ì´ ì•„í‚¤í…ì²˜ ì»´í¬ë„ŒíŠ¸ëŠ” ë¼ì´ë¸Œì‚¬ì´í´ ì˜µì €ë²„ì™€ í•¨ê»˜ ì œê³µë©ë‹ˆë‹¤. ì´ë¦„ì—ì„œ ì¶”ì¸¡í•  ìˆ˜ ìˆë“¯ì´ êµ¬ì„±ìš”ì†Œì˜ ë¼ì´í”„ì‚¬ì´í´ì„ ë°”ì¸ë”©í•  ì˜µì €ë²„ë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.`

In the below example SomeObserver is implementing LifecycleObserver class. 
SomeObserver is bound to an activity so it will follow activityâ€™s lifecycle. 

`ì•„ë˜ ì˜ˆì œëŠ” ë¼ì´í”„ì‚¬ì´í´ì˜µì €ë²„ í´ë˜ìŠ¤ë¥¼ êµ¬í˜„í•˜ê³  ìˆìŠµë‹ˆë‹¤. ì˜µì €ë²„ëŠ” ì•¡í‹°ë¹„í‹°ì— ë°”ì¸ë”© ë˜ì–´ìˆìœ¼ë¯€ë¡œ ì•¡í‹°ë¹„í‹° ë¼ì´í”„ì‚¬ì´í´ì„ ë”°ë¦…ë‹ˆë‹¤.`

As Activityâ€™s onResume gets called, onResume of SomeObserver will also be called since it is linked to ON_RESUME event of Activity.

`ì•¡í‹°ë¹„í‹°ì˜ onResumeì´ í˜¸ì¶œë˜ë©´ ì˜µì €ë²„ì˜ onResume ë˜í•œ ì•¡í‹°ë¹„í‹° onResumeì´ë²¤íŠ¸ì— ì—°ê²°ë˜ì–´ìˆê¸° ë•Œë¬¸ì— í˜¸ì¶œë©ë‹ˆë‹¤.`

```kotlin
// registering observer in activity class
getLifecycle().addObserver(new SomeObserver());
// implementing LifecycleObserver class
public class SomeObserver implements LifecycleObserver {

    final String TAG = this.getClass().getSimpleName().toString();

    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
    public void onResume() {
        Log.d(TAG, "onResume called");
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
    public void onPause() {
        Log.d(TAG, "onPause called");
    }
}
```

Use case: You want to fetch userâ€™s fine location only if activity is visible. if not then coarse location.

`ì‚¬ìš©ì‚¬ë¡€: ì•¡í‹°ë¹„í‹°ê°€ ë³´ì—¬ì§€ëŠ” ê²½ìš°ì—ë§Œ ìœ ì €ì˜ ì •í™•í•œ ìœ„ì¹˜ë¥¼ ì°¾ê¸°ë¥¼ ì›í•  ë•Œ. ê·¸ë ‡ì§€ ì•Šì„ ê²½ìš° ëŒ€ëµì ì¸ ìœ„ì¹˜.`

For this, In the observer class for onResume and onPause method you can switch the location update source from coarse to fine or vice-versa.

`ì´ëŸ° ê²½ìš° onResumeì™€ onPause ë©”ì†Œë“œì— ëŒ€í•œ ì˜µì €ë²„ í´ë˜ìŠ¤ì—ì„œ ëŒ€ëµì ì—ì„œ ì •í™•í•˜ê²Œ í˜¹ì€ ë°˜ëŒ€ë¡œ ìœ„ì¹˜ë¥¼ ì—…ë°ì´íŠ¸í•˜ë„ë¡ ì „í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`

Fragments and Activities already implement the LifeCycleOwner interface in Support Library 26.1.0 and later. 

`í”„ë˜ê·¸ë¨¼íŠ¸ë‚˜ ì•¡í‹°ë¹„í‹°ë“¤ì€ ì´ë¯¸ ë¼ì´í”„ì‚¬ì´í´ì˜µì €ë²„ ì¸í„°í˜ì´ìŠ¤ë¥¼ í•´ë‹¹ ë²„ì „ê³¼ ì´í›„ì—ì„œ êµ¬í˜„í•©ë‹ˆë‹¤.`

Before that you would have to extend LifeCycleFragment or LifeCycleActivity for fragment and activity correspondingly.

`ê·¸ ì „ì— í”„ë˜ê·¸ë¨¼íŠ¸ë‚˜ ì•¡í‹°ë¹„í‹°ì— ëŒ€í•´ ë¼ì´í”„ì‚¬ì´í´ í”„ë˜ê·¸ë¨¼íŠ¸ë‚˜ ë¼ì´í”„ì‚¬ì´í´ ì•¡í‹°ë¹„í‹°ë¥¼ ìƒì‘í•˜ê²Œ í™•ì¥í•´ì•¼í•©ë‹ˆë‹¤.`

Also, You can make your own class Lifecycle Owner by implementing LifeCycleOwner class and mark the methods which you want to expose using LifecycleRegistry.

`ë˜í•œ ë¼ì´í”„ì‚¬ì´í´ ì†Œìœ ë¥¼ êµ¬í˜„í•¨ìœ¼ë¡œì¨ LifeCycleOwner í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ê³  LifecycleRegistryë¥¼ ì‚¬ìš©í•˜ì—¬ ë…¸ì¶œí•˜ê³ ìí•˜ëŠ” ë©”ì†Œë“œë¥¼ í‘œì‹œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`

```kotlin
public class MyActivity extends Activity implements LifecycleOwner {
    private LifecycleRegistry mLifecycleRegistry;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mLifecycleRegistry = new LifecycleRegistry(this);
        mLifecycleRegistry.markState(Lifecycle.State.CREATED);
    }

    @Override
    public void onStart() {
        super.onStart();
        mLifecycleRegistry.markState(Lifecycle.State.STARTED);
    }

    @NonNull
    @Override
    public Lifecycle getLifecycle() {
        return mLifecycleRegistry;
    }
}
```

We are done with Architecture components. Letâ€™s talk about MVVM Architecture now.

`ìš°ë¦¬ëŠ” ì•„í‚¤í…ì²˜ êµ¬ì„±ìš”ì†Œë¥¼ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤. MVVM ì•„í‚¤í…ì²˜ì— ëŒ€í•´ ì§€ê¸ˆ ë§í•´ë³´ê² ìŠµë‹ˆë‹¤.`

