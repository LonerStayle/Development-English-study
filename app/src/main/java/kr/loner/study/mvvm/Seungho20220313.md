# ì˜ì–´ìŠ¤í„°ë”” ì‹œì¦Œ 5 7ì£¼ì°¨

created by [seungho](https://github.com/devaspirant0510) on 2022-03-13

[document link](https://proandroiddev.com/our-way-to-mvvmi-and-mistakes-we-made-when-implementing-mvvm-5f5448b5ad50)

# ğŸ“— ë‹¨ì–´ ì •ë¦¬ ğŸ“˜

|ì˜ì–´|í•œê¸€|
|----|----|
|indeed|ì •ë§ë¡œ|
|readability|ì¬ë¯¸ìˆê²Œ ì½ì„ìˆ˜ìˆëŠ”,ê°€ë…ì„±|
|stability|ì•ˆì •ì„±|
|make sense|ì´í•´ê°€ëœë‹¤,ë§ì´ëœë‹¤|
|purpose|ëª©ì |


## Our Way to MVVMI and Mistakes We Made When Implementing MVVM

`ìš°ë¦¬ì˜ mvvm ìœ¼ë¡œ ê°€ëŠ”ê¸¸ê³¼ ìš°ë¦¬ê°€ mvvm ì„ êµ¬í˜„í• ë•Œ ë§Œë“  ì‹¤ìˆ˜`

My story on this project started with the managementâ€™s decision of refactoring it as developers had hit the wall with
â€œGodâ€ Activities, static fields that held Context, endless memory leaks and â€œworkaroundsâ€ in the code base and managers
were tired of a flaky and bugged product in production.  
`ì´ í”„ë¡œì íŠ¸ì— ëŒ€í•œ ë‚´ ì´ì•¼ê¸°ëŠ” ê°œë°œìê°€ "God" í™œë™, ì»¨í…ìŠ¤íŠ¸ë¥¼ ìœ ì§€í•˜ëŠ” ì •ì  í•„ë“œ, ì½”ë“œ ê¸°ë°˜ì˜ ëì—†ëŠ” ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë° "í•´ê²° ë°©ë²•"ìœ¼ë¡œ ë²½ì—
ë¶€ë”ªí˜”ê³  ê´€ë¦¬ìê°€ ë¹„ì •ìƒì  ë° ë²„ê·¸ê°€ ìˆëŠ” ì œí’ˆì„ ìƒì‚° ì¤‘ì…ë‹ˆë‹¤.`

Therefore the best option seemed to refactor the project (or at this point rewrite it) to follow a layered architecture
pattern.  
`ê·¸ëŸ¬ë¯€ë¡œ ìµœê³ ì˜ ì˜µì…˜ì€ ê³„ì¸µì ì¸ ì•„í‚¤í…ì³íŒ¨í„´ì„ ë”°ë¼ í”„ë¡œì íŠ¸ë¥¼ ë¦¬íŒ©í† ë§(ë˜ëŠ” í”„ë¡œì íŠ¸ë¥¼ ë‹¤ì‹œì‘ì„±)í•˜ëŠ”ê²ƒ ê°™ë‹¤.`

The choice was given to MVVM.  
`ì„ íƒì€ MVVM ì„ ì£¼ì–´ì¡Œë‹¤.`

![image](https://user-images.githubusercontent.com/68223593/158017222-81e227dd-7dc2-445c-8390-c12b00c0518d.png)

It is not a secret that Google positions using MVVM (Model-View-ViewModel) as the most efficient choice of 
Android architecture.  
`êµ¬ê¸€ì´mvvmì„ ì‚¬ìš©í•˜ì—¬ ì•ˆë“œë¡œì´ë“œ ì•„í‚¤í…ì³ì—ì„œ ëŒ€ë¶€ë¶„ì˜ íš¨ê³¼ì ì¸ ì„ íƒìœ¼ë¡œ ë‘ëŠ”ê²ƒì€ ë¹„ë°€ì´ ì•„ë‹ˆë‹¤. `

When reading the Guide to app architecture you can see examples of Architecture Components applied to a 
layered architecture pattern.   
`ì•± ì•„í‚¤í…ì³ ê°€ì´ë“œë¥¼ ì½ì„ë•Œ ë„ˆëŠ” ì•„í‚¤í…ì³ì»´í¬ë„ŒíŠ¸ì—ì„œ ê³„ì¸µí™”ëœ ì•„í‚¤í…ì³íŒ¨í„´ì„ ì ìš©í•˜ëŠ”ê²ƒì„ ì˜ˆì‹œë¡œ ë³¼ìˆ˜ìˆë‹¤. `

My team sure thing read this piece and got to implementing it in our project.  
`ë‚´ íŒ€ì€ í™•ì‹¤íˆ ì´ëŸ¬í•œ ê²ƒë“¤ì„ ì½ì—ˆê³  ìš°ë¦¬ì˜ í”„ë¡œì íŠ¸ì— êµ¬í˜„í•˜ì˜€ë‹¤.`

At first migrating to MVVM, indeed, increased the readability and stability of the code base.   
`ì²˜ìŒì— mvvmìœ¼ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜í• ë•Œ ,ì •ë§ë¡œ, ì½”ë“œê¸°ë°˜ì˜ ê°€ë…ì„±ê³¼ ì•ˆì •ì„±ì´ ì¦ê°€í•˜ì˜€ë‹¤.`

However several mistakes we made along the way created new issues that I am going to talk about next.  
`ê·¸ëŸ¬ë‚˜ ëª‡ëª‡ ì‹¤ìˆ˜ë¡œ ì¸í•´ ìš°ë¦¬ë¥¼ ë‚´ê°€ ë‹¤ìŒì— ì†Œê°œí•  ìƒˆë¡œìš´ ì´ìŠˆë¥¼ ë§Œë“¤ê²Œí•˜ì˜€ë‹¤. `

Mistake 1: Passing LiveData objects as params to repository and updating the value there.  
`ì‹¤ìˆ˜ 1 : livedata ê°ì²´ë¥¼ íŒŒë¼ë¯¸í„°ë¡œ ë ˆí¬ì§€í† ë¦¬ì— ì „ë‹¬í•˜ê³  ê°’ì„ ê±°ê¸°(ë ˆí”¼ì§€í† ë¦¬)ì—ì„œ ì—…ë°ì´íŠ¸í•˜ì˜€ë‹¤.`

Yes, we did that at first.   
`ë§ë‹¤ ìš°ë¦¬ëŠ” ì²˜ìŒì—ëŠ” ê·¸ë ‡ê²Œ í•˜ì˜€ë‹¤.`

Creating an instance of LiveData in ViewModel then passing it to repository and setting 
new value when a server response is received.  
`viewmodel ì—ì„œ livedata instance ë¥¼ ìƒì„±í–ˆê³  ë ˆíŒŒì§€í† ë¦¬ë¡œ ì „ë‹¬í•˜ê³  ì„œë²„ì—ì„œ ë°ì´í„°ë¥¼ ì‘ë‹µë°›ì„ë•Œ 
ìƒˆë¡œìš´ ê°’ì„ ì„¸íŒ…í–ˆë‹¤.`

After that, View was notified and passed this value back to ViewModel to handle the logic.  
`ê·¸ë¦¬ê³ ë‚˜ì„œ ë·°ëŠ” ì•Œë¦¬ê³  ê°’ì„ ë‹¤ì‹œ ë·°ëª¨ë¸ë¡œ ì „ë‹¬í•˜ì—¬ ë¡œì§ì„ ì²˜ë¦¬í•œë‹¤.` 

This approach left us with an untestable architecture.  
`ì´ ì ‘ê·¼ì€ ë‚¨ê²¼ë‹¤. ìš°ë¦¬ì—ê²Œ í…ŒìŠ¤íŠ¸ê°€ëŠ¥í•˜ì§€ ëª»í•œ ì•„í‚¤í…ì³`


Even though the architecture is layered, the layers are not decoupled enough to be unit tested.   
`ì•„í‚¤í…ì²˜ê°€ ê³„ì¸µí™”ë˜ì–´ ìˆë”ë¼ë„ ê³„ì¸µì€ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë¥¼ ìˆ˜í–‰í•  ë§Œí¼ ì¶©ë¶„íˆ ë¶„ë¦¬ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.`

So it created a problem with writing small and transparent unit tests.  
`ê·¸ë˜ì„œ ì‘ê³  íˆ¬ëª…í•œ ë‹¨ìœ„í…ŒìŠ¤íŠ¸ë¥¼ í• ë–„ ë¬¸ì œë¥¼ ë§Œë“¤ì—ˆë‹¤.`

And one of the major advantages that this kind of architecture can provide is testability
which was missing.  
`ê·¸ë¦¬ê³  ì´ëŸ¬í•œ ì•„í‚¤í…ì²˜ê°€ ì œê³µí•  ìˆ˜ ìˆëŠ” ì£¼ìš” ì´ì  ì¤‘ í•˜ë‚˜ëŠ” ëˆ„ë½ëœ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„±ì…ë‹ˆë‹¤. `

Solution: We came to the realization that using LiveData has the greatest impact when 
propagating changes to View because of its lifecycle awareness.  
`í•´ê²°ì±… : ìš°ë¦¬ëŠ” ë¼ì´ë¸Œë°ì´í„°ë¥¼ ì‚¬ìš©í•˜ëŠ”ê²ƒì´ ìƒëª…ì£¼ê¸° ì¸ì‹ë•Œë¬¸ì— ë³€ê²½ì„ ë·°ì— ì „íŒŒí• ë•Œ ê°€ì¥ í° ì˜í–¥ì„ ë¼ì¹œë‹¤ëŠ”ê²ƒì„ ê¹¨ë‹¬ì•˜ë‹¤.`

We made repository return a RxJava type.  
`ìš°ë¦¬ëŠ” ë ˆí¬ì§€í† ë¦¬ê°€ Rxjava íƒ€ì…ì„ ë¦¬í„´í•˜ê²Œ ë§Œë“¤ì—ˆë‹¤.`

ViewModel subscribes to it and then when the value is ready to be propagated to View, 
it is posted to LiveData observed by View.  
`ë·°ëª¨ë¸ì€ ê·¸ê²ƒ(ë ˆíŒŒì§€í† ë¦¬ê°€ ë¦¬í„´í•˜ëŠ” RxJava íƒ€ì…) ê·¸ê²ƒì„ êµ¬ë…í•˜ê³  ê°’ì€ ë·°ì— ì „íŒŒí•  ì¤€ë¹„ê°€ ë˜ì–´ìˆê³ ,
ê·¸ê²ƒì€ ë·°ë¡œë¶€í„° ê´€ì±ƒí•˜ê³ ìˆëŠ” ë¼ì´ë¸Œë°ì´í„°ë¥¼ ê²Œì‹œí•œë‹¤.`

LiveData + Reactive pattern shine even more when using databinding.  
`ë¼ì´ë¸Œë°ì´í„° + ë¦¬ì•¡í‹°ë¸Œ íŒ¨í„´ì€ ë°ì´í„°ë¥¼ ë°ì´í…Œë°”ì¸ë”©ì„ ì‚¬ìš©í• ë–„ ë¹›ë‚œë‹¤.`

Advantages: No more passing the ball around(LiveData objects), the communicating between 
layers is linear and transparent.  
`ì¥ì  : ë”ì´ìƒ ë¼ì´ë¸Œë°ì´í„° ê°ì²´ë¥¼ í†µê³¼í•˜ì§€ ì•Šì•„ë„ ë ˆì´ì–´ê°„ í†µì‹ ì´ ì„ í˜•ì ì´ê³  íˆ¬ëª…í•´ì§‘ë‹ˆë‹¤.`

Mistake 2: Combining business logic and presentation logic in ViewModel.  
`ì‹¤ìˆ˜2  : ë¹„ì¦ˆë‹ˆìŠ¤ë¡œì§ê³¼ í”„ë ˆì  í…Œì´ì…˜ë¡œì§ì„ ë‘˜ë‹¤ ë·°ëª¨ë¸ì— ì‘ì„±`

The purpose of ViewModel is to hold the presentation logic but there is another type of logic â€” business logic.   
`ë·°ëª¨ë¸ì˜ ëª©ì ì€ í”„ë ˆì  í…Œì´ì…˜ë¡œì§ì„ ë³´ìœ í•˜ê³ ìˆëŠ”ê²ƒì´ë‹¤. ê·¸ëŸ¬ë‚˜ ê±°ê¸°ì— ë‹¤ë¥¸ íƒ€ì…ì˜ ë¡œì§(ë¹„ì¦ˆë‹ˆìŠ¤ë¡œì§ì´) ìˆë‹¤.`

The question is â€” Where to place it?  
`ë¬¸ì œëŠ” ì–´ë””ì— ë†“ì•„ì•¼í• ê¹Œ?`

When the project is small at the beginning, it makes sense to have it in ViewModel but with the course of 
the project added functionality and therefore more code creates a problem of a â€œGodâ€ ViewModel 
which knows about formatting, validation and data transformations and also holds the View logic.  
`í”„ë¡œì íŠ¸ê°€ ì‹œì‘í•˜ì—¬ ì‘ì€ê·œëª¨ì¼ë•Œ, ê·¸ê²ƒì€ ë·°ëª¨ë¸ì— ìœ„ì¹˜í•˜ëŠ”ê²ƒì€ ë§ì´ëœë‹¤. ê·¸ëŸ¬ë‚˜ í”„ë¡œì íŠ¸ê³¼ì •ì—ì„œ ê¸°ëŠ¥ì´ ì¶”ê°€ë˜ê³  ë”°ë¼ì„œ ë” ë§ì€ ì½”ë“œê°€ GOD ë·°ëª¨ë¸ì˜
ë¬¸ì œë¥¼ ë§Œë“­ë‹ˆë‹¤. í¬ë§·íŒ…,ìœ íš¨ì„±ê²€ì‚¬ ë° ë°ì´í„°ë³€í™˜ì— ëŒ€í•´ ì•Œê³   ë·°ë¡œì§ë„ ì•„ëŠ” `

Solution: The way out was to create an intermediate level between Repository and ViewModel which is usually 
called Interactor or UseCase to hold business logic.   
`í•´ê²°ì±… : í•´ê²°ì±…ì€ ë ˆí¬ì§€í† ë¦¬ì™€ ë·°ëª¨ë¸ì‚¬ì´ì˜ ì¤‘ê°„ë ˆë²¨ì„ ìƒì„±í•˜ëŠ”ê²ƒì…ë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ ì¸í„°ë ‰í„° ë˜ëŠ” ìœ ì¦ˆì¼€ì´ìŠ¤ë¼ê³  ë¶ˆë¦¬ëŠ” ë¹„ì¦ˆë‹ˆìŠ¤ë¡œì§ì„ `
 
The purpose of Interactor is to hold purely business logic.   
`ì¸í„°ë™í„°ì˜ ëª©ì ì€ ìˆœìˆ˜í•œ ë¹„ì¦ˆë‹ˆìŠ¤ë¡œì§ì„ ë³´ìœ í•˜ê³ ìˆìŠµë‹ˆë‹¤.`

Advantages: The main one is testability.   
`ì¥ì  : ê°€ì¥ ì¤‘ìš”í•œê²ƒì€ ë°ìŠ¤íŠ¸ê°€ëŠ¥í•˜ë‹¤ëŠ”ê²ƒì…ë‹ˆë‹¤.`
Interactor class with no references to the Android Framework supports testing with JUnit and Mockito only.  
`ì¸í„°ë ‰í„°í´ë˜ìŠ¤ëŠ” ì•ˆë“œë¡œì´ë“œ í”„ë ˆì„ì›Œí¬ë¥¼ ì°¸ì¡°í•˜ì§€ ì•Šê¸°ë–„ë¬¸ì— JUnit ê³¼ Mockito ë˜í•œ í…ŒìŠ¤íŒ…ì„ ì§€ì›í•©ë‹ˆë‹¤.`

Moreover, having Interactor decreases the size of ViewModels and therefore we gain in readability.  
`ê²Œë‹¤ê°€ ì¸í„°ë ‰í„°ë¥¼ ê°€ì§€ë©´ ë·°ëª¨ë¸ì˜ ì‚¬ì´ì¦ˆëŠ” ê°ì†Œí•˜ê³  ê·¸ëŸ¬ë¯€ë¡œ ê°€ë…ì„±ì„ ì–»ìŠµë‹ˆë‹¤.`

![image](https://user-images.githubusercontent.com/68223593/158043397-aa727b94-822e-41fd-9c32-4eb90985e0f9.png)
