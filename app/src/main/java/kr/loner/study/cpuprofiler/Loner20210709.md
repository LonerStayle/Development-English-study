# Inspect your app's memory usage with Memory Profiler ~ Why you should profile your app memory   
   
## ê°œë…    
   
### ë©”ëª¨ë¦¬ í”„ë¡œíŒŒì¼ëŸ¬ë€?   
 ë©”ëª¨ë¦¬ í”„ë¡œíŒŒì¼ëŸ¬ëŠ” ì•±ì˜ ë©”ëª¨ë¦¬ ì‚¬ìš© í˜„í™©ì„ ì‹¤ì‹œê°„ ê·¸ë˜í”„ë¡œ ë³´ì—¬ì£¼ë©°,    
 ë©”ëª¨ë¦¬ í”„ë¡œíŒŒì¼ëŸ¬ë¥¼ ì‚¬ìš©í•˜ì—¬ í™ ë¤í”„ë¥¼ ìº¡ì²˜í•˜ê³     
 ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ì„ ê°•ì œ ì‹¤í–‰í•˜ê³  ë©”ëª¨ë¦¬ í• ë‹¹ì„ ì¶”ì í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.   
    
### ì•± ë©”ëª¨ë¦¬ë¥¼ í”„ë¡œíŒŒì¼ë§ í•´ì•¼í•˜ëŠ” ì´ìœ ?    
ì‹œìŠ¤í…œì—ì„œ ë©”ëª¨ë¦¬ë¥¼ ìˆ˜ì§‘í•  ìˆ˜ ìˆëŠ” ê²ƒë³´ë‹¤ ë¹ ë¥´ê²Œ ì•±ì—ì„œ ë©”ëª¨ë¦¬ë¥¼ í• ë‹¹í•˜ëŠ” ê²½ìš°    
GCê°€ í• ë‹¹í•˜ê¸°ì— ì¶©ë¶„í•œ ë©”ëª¨ë¦¬ë¥¼ í™•ë³´í•˜ëŠ” ë™ì•ˆ ì•±ì´ ì§€ì—°ë  ìˆ˜ ìˆê³ ,   
   
ì•±ì´ ëŠë ¤ì§€ì§€ ì•Šë”ë¼ë„ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ê°€ ë°œìƒí•  ê²½ìš° ì•±ì´ ë°±ê·¸ë¼ìš´ë“œì— ìˆëŠ” ë™ì•ˆì—ë„ ë©”ëª¨ë¦¬ë¥¼ ìœ ì§€í•  ìˆ˜ ìˆì–´ì„œ    
ì´ ë™ì‘ìœ¼ë¡œ ì¸í•´ ë¶ˆí•„ìš”í•œ GC ì´ë²¤íŠ¸ê°€ ê°•ì œë¡œ ì‹¤í–‰ë˜ì–´ ì‹œìŠ¤í…œì˜ ë‚˜ë¨¸ì§€ ë©”ëª¨ë¦¬ ì„±ëŠ¥ì´ ì €í•˜ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.    
   
ê²°êµ­ ì‹œìŠ¤í…œì—ì„œ ë©”ëª¨ë¦¬ë¥¼ í™•ë³´í•˜ê¸° ìœ„í•´ ì•± í”„ë¡œì„¸ìŠ¤ë¥¼ ê°•ì œ ì¢…ë£Œí•´ì•¼ í•©ë‹ˆë‹¤.(Out of Memory Exception)   
   
---------------------------------------------------   
   
   
## ì˜ì–´ í•´ì„ 
#### Inspect your app's memory usage with Memory Profiler   
ë©”ëª¨ë¦¬ í”„ë¡œíŒŒì¼ëŸ¬ë¡œ ì•±ì˜ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ê²€ì‚¬   
   
+ usage ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ì‚¬ìš©ë²•ì´ë€ ëœ»ì„ ê°€ì§€ì§€ë§Œ Memory usage ëŠ” ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ëœ»í•¨   
+ with +ë„êµ¬ -> with ë’¤ì— ì‚¬ëŒì´ ì•„ë‹ˆë¼ ë„êµ¬ê°€ ì˜¨ë‹¤ë©´ ë„êµ¬ë¥¼ ì‚¬ìš©í•œë‹¤ëŠ” ëœ»ì´ ë¨   
   
#### The Memory Profiler is a component in the Android Profiler that helps   
#### you identify memory leaks and memory churn that can lead to stutter, freezes, and even app crashes.     
ë©”ëª¨ë¦¬ í”„ë¡œíŒŒì¼ëŸ¬ëŠ” ëŠê¹€, ì •ì§€ ë° ì•± ì¶©ëŒë¡œ ì´ì–´ì§ˆ ìˆ˜ ìˆëŠ” ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë° ë©”ëª¨ë¦¬ ë³€ë™ì„ ì‹ë³„í•˜ëŠ” ë°   
ë„ì›€ì´ ë˜ëŠ” Android í”„ë¡œíŒŒì¼ëŸ¬ì˜ êµ¬ì„±ìš”ì†Œì…ë‹ˆë‹¤.   
   
+ that ì´ ì—¬ëŸ¬ë²ˆ ë¶™ìœ¼ë‹ˆ ì •ì‹ ì´ ì—†ë‹¤.. ì°¸ê³  ì‚¬ì´íŠ¸ (https://brunch.co.kr/@chutzu-paichia/155)   
+ can lead to -> ë¡œ ì´ì–´ì§ˆ ìˆ˜ ìˆë‹¤.   
   
#### It shows a realtime graph of your app's memory use and    
ì•±ì˜ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì— ëŒ€í•œ ì‹¤ì‹œê°„ ê·¸ë˜í”„ë¥¼ ë³´ì—¬ì£¼ê³    
   
#### lets you capture a heap dump, force garbage collections, and track memory allocations.   
heep dump ë¥¼ ìº¡ì³, ê°€ë¹„ì§€ì½œë ‰í„° ê°•ì œì‹¤í–‰ ê·¸ë¦¬ê³  ë©”ëª¨ë¦¬ í• ë‹¹ì„ ì¶”ì í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.   
   
#### To open the Memory Profiler, follow these steps   
ë©”ëª¨ë¦¬ í”„ë¡œíŒŒì¼ëŸ¬ë¥¼ ì—´ë ¤ë©´, ì´ ë‹¨ê³„ë¥¼ ë”°ë¥´ì„¸ìš”   
   
#### 1. Click View > Tool Windows > Profiler (you can also click Profile  in the toolbar).   
View -> Tool Windows -> Profiler ë¥¼ í´ë¦­í•˜ì„¸ìš” (í˜¹ì€ íˆ´ë°”ì—ì„œ í”„ë¡œíŒŒì¼ëŸ¬ë¥¼ í´ë¦­í•  ìˆ˜ ìˆë‹¤.)   
   
#### 2. Select the device and app process you want to profile from the Android Profiler toolbar.   
ì•ˆë“œë¡œì´ë“œ í”„ë¡œíŒŒì¼ëŸ¬ íˆ´ë°”ì—ì„œ í”„ë¡œíŒŒì¼ë§ í•   device ë° ì•± í”„ë¡œì„¸ìŠ¤ë¥¼ ì„ íƒí•œë‹¤.   
   
#### If you've connected a device over USB but don't see it listed,   
ë§Œì•½ USBë¥¼ í†µí•´ ì¥ì¹˜ë¡œ ì—°ê²°í•œ ê²½ìš° ê·¸ëŸ¬ë‚˜ ëª©ë¡ì—ì„œ ë³´ì´ì§€ ì•Šì„ ë•Œ   
   
+ A over USB -> USBë¥¼ í†µí•œ A    
   
#### ensure that you have enabled USB debugging.   
USB ë””ë²„ê¹…ì„ í™œì„±í™” í–ˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.   
   
+ ensure + have -> ~ ê°€ì§€ê³  ìˆëŠ”ì§€ í™•ì¸   
   
#### Click anywhere in the MEMORY timeline to open the Memory Profiler.   
ë©”ëª¨ë¦¬ íƒ€ì„ë¼ì¸ì—ì„œ ì•„ë¬´ê³³ì´ë‚˜ í´ë¦­í•´ì„œ ë©”ëª¨ë¦¬ í”„ë¡œíŒŒì¼ëŸ¬ë¥¼ ì—½ë‹ˆë‹¤.   
   
#### Alternatively, you can inspect your app memory from the command line with dumpsys,   
ëŒ€ì•ˆìœ¼ë¡œ, dumpsysë¥¼ ì‚¬ìš©í•´ì„œ ëª…ë ¹ì¤„ë¡œ ì•± ë©”ëª¨ë¦¬ë¥¼ ê²€ì‚¬ í•  ìˆ˜ ìˆë‹¤.   
    
#### and also see GC events in logcat.  
ê·¸ë¦¬ê³  ë˜í•œ ë¡œê·¸ìº£ì—ì„œ GC ì´ë²¤íŠ¸ë¥¼ ì°¸ì¡° í•  ìˆ˜ ìˆë‹¤.   
   
also see -> ë˜í•œ ì°¸ì¡°   
   
#### Why you should profile your app memory   
ì•± ë©”ëª¨ë¦¬ í”„ë¡œíŒŒì¼ëŸ¬ë¥¼ ì™œ í•´ì•¼í•˜ëŠ”ì§€   
   
#### Android provides a managed memory environment   
ì•ˆë“œë¡œì´ë“œëŠ” ë©”ëª¨ë¦¬ ê´€ë¦¬ í™˜ê²½ì„ ì œê³µí•©ë‹ˆë‹¤.   
   
#### when it determines that your app is no longer using some objects,   
ì•±ì´ ë” ì´ìƒ ì¼ë¶€ Objects ë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ”ë‹¤ê³  íŒë‹¨ë˜ë©´   
   
+ no longer -> ë” ì´ìƒ    
   
#### the garbage collector releases the unused memory back to the heap.   
ê°€ë¹„ì§€ ì½œë ‰í„°ê°€ ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ë©”ëª¨ë¦¬ëŠ” ë‹¤ì‹œ í™ìœ¼ë¡œ í•´ì œ í•©ë‹ˆë‹¤.   
   
+ ìœ„ ë¬¸ì¥ì˜ release ëŠ” í•´ì œë˜ë‹¤ë¡œ ì‚¬ìš© ë¨   
   
#### How Android goes about finding unused memory is constantly being improved   
ì–´ë–»ê²Œ ì•ˆë“œë¡œì´ë“œê°€ ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ë©”ëª¨ë¦¬ë¥¼ ì°¾ì„ì§€ëŠ” ì§€ì†ì ìœ¼ë¡œ ê°œì„ ë˜ê³  ìˆìŠµë‹ˆë‹¤.   
   
#### but at some point on all Android versions, the system must briefly pause your code.   
ê·¸ëŸ¬ë‚˜ ì•ˆë“œë¡œì´ë“œ ëª¨ë“  ë²„ì „ì˜ ì–´ëŠ ì‹œì ì—ì„œ ì‹œìŠ¤í…œì€ ì½”ë“œë¥¼ ê°„ë‹¨íˆ ì¼ì‹œ ì¤‘ì§€ í•´ì•¼ í•©ë‹ˆë‹¤.   
    
+ must -> ~ í•´ì•¼í•œë‹¤ (ì´ ê°„ë‹¨í•œ ê±¸ most ë‘ ì™œ í—·ê¹”ë¦¼..)   
   
#### Most of the time, the pauses are imperceivable.   
ì‹œê°„ì˜ ëŒ€ë¶€ë¶„, ì¼ì‹œ ì •ì§€ëŠ” ê°ì§€í•  ìˆ˜ ì—†ë‹¤.   
   
+ imperceivable. - > ê°ì§€ í•  ìˆ˜ ì—†ë‹¤.   
   
#### However, if your app allocates memory faster than the system can collect it,   
ê·¸ëŸ¬ë‚˜, ì•±ì´ ì‹œìŠ¤í…œì—ì„œ ìˆ˜ì§‘í•  ìˆ˜ ìˆëŠ”ê²ƒ ë³´ë‹¤ ë¹ ë¥´ê²Œ ë©”ëª¨ë¦¬ í• ë‹¹ì´ ëœë‹¤ë©´    
   
+ A then the -> A ë³´ë‹¤   
   
#### your app might be delayed while the collector frees enough memory to satisfy your allocations.   
collector ê°€ í• ë‹¹ì„ ì¶©ì¡±í•˜ê¸°ì— ì¶©ë¶„í•œ ë©”ëª¨ë¦¬ë¥¼ í™•ë³´í•˜ëŠ” ë™ì•ˆ ì•±ì´ ì§€ì—°ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.   
   
+ frees -> í’€ì–´ì£¼ë‹¤, í•´ì œ    
   
#### The delay could cause your app to skip frames and cause visible slowness.   
ë”œë ˆì´ë¡œ ì¸í•´ ì•±ì´ í”„ë ˆì„ì„ ìŠ¤í‚µí•˜ê±°ë‚˜ ëˆˆì— ë„ê²Œ ëŠë ¤ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.   
   
+ The delay could cause -> ë”œë ˆì´ë¡œ ì¸í•´   
   
#### Even if your app doesn't exhibit slowness,   
ì•±ì´ ëŠë ¤ì§€ì§€ ì•Šë”ë¼ë„   
   
+ Even if vs Even Though (https://confusingtimes.tistory.com/1003)    
   
#### if it leaks memory, it can retain that memory even while it's in the background.   
ë§Œì•½ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ì¼ ë•Œ, ë°±ê·¸ë¼ìš´ë“œì— ìˆëŠ” ë™ì•ˆì— í•´ë‹¹ ë©”ëª¨ë¦¬ê°€ ìœ ì§€ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.   
   
+ even while it`s in the background -> ë°±ê·¸ë¼ìš´ë“œì— ìˆëŠ” ë™ì•ˆì—ë„   
   
#### This behavior can slow the rest of the system's memory performance by forcing unnecessary garbage collection events.   
ì´ ë™ì‘ì€ ë¶ˆí•„ìš”í•œ ê°€ë¹„ì§€ ì½œë ‰í„° ì´ë²¤íŠ¸ë¥¼ ê°•ì œí•˜ì—¬ ì‹œìŠ¤í…œì˜ ë‚˜ë¨¸ì§€ ë©”ëª¨ë¦¬ í¼í¬ë¨¼ìŠ¤ë¥¼ ëŠë¦¬ê²Œ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.   
   
+ rest of the System`s memory performance -> ì‹œìŠ¤í…œì˜ ë‚˜ë¨¸ì§€ ë©”ëª¨ë¦¬ í¼í¬ë¨¼ìŠ¤   
   
#### Eventually, the system is forced to kill your app process to reclaim the memory.   
ê²°êµ­, ì‹œìŠ¤í…œì€ ë©”ëª¨ë¦¬ë¥¼ íšŒìˆ˜í•˜ê¸° ìœ„í•´ ê°•ì œë¡œ ì•± í”„ë¡œì„¸ìŠ¤ë¥¼ ì£½ì…ë‹ˆë‹¤.   
   
#### Then when the user returns to your app, it must restart completely.   
ê·¸ëŸ° ë‹¤ìŒ ì‚¬ëŒë“¤ì´ ì•±ìœ¼ë¡œ ëŒì•„ì˜¤ë©´ ì™„ì „íˆ ë‹¤ì‹œ ì‹œì‘í•´ì•¼í•©ë‹ˆë‹¤.   
   
#### To help prevent these problems, you should use the Memory Profiler to do the following   
ì´ëŸ¬í•œ ë¬¸ì œë¥¼ ë§‰ìœ¼ë ¤ë©´, ë©”ëª¨ë¦¬ í”„ë¡œíŒŒì¼ëŸ¬ë¥¼ ì‚¬ìš©í•´ì„œ ë‹¤ìŒì„ ë”°ë¼ì•¼í•œë‹¤.   
   
#### Look for undesirable memory allocation patterns in the timeline that might be causing performance problems.   
íƒ€ì„ë¼ì¸ì—ì„œ ì„±ëŠ¥ ë¬¸ì œë¥¼ ì¼ìœ¼í‚¬ë§Œí•œ ë°”ëŒì§í•˜ì§€ ì•ŠëŠ” ë©”ëª¨ë¦¬ í• ë‹¹ íŒ¨í„´ë“¤ì„ ì°¾ìŠµë‹ˆë‹¤.   
   
#### Dump the Java heap to see which objects are using up memory at any given time.   
java heep ì„ Dump í•´ì„œ ì£¼ì–´ì§„ ì‹œê°„ì— ì–´ë–¤ object ê°€ ë©”ëª¨ë¦¬ë¥¼ ì‚¬ìš©í•˜ëŠ”ì§€ ë´…ë‹ˆë‹¤.   

+ at any given time -> ì£¼ì–´ì§„ ì‹œê°„ì—   
   
#### Several heap dumps over an extended period of time can help identify memory leaks.   
ì¥ê¸°ê°„ì— ê±¸ì¹œ ì—¬ëŸ¬ í™ ë¤í”„ëŠ” ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ë¥¼ ì‹ë³„í•˜ëŠ”ë° ë„ì›€ì„ ì¤„ ìˆ˜ ìˆë‹¤.   
   
+ over an extended period of time ->  ì¥ê¸°ê°„ì— ê±¸ì³
 
#### Record memory allocations during normal and extreme user interaction to identify exactly   
#### where your code is either allocating too many objects in a short time or allocating objects that become leaked.   
ì •ìƒ ë° ê·¹ë‹¨ì ì¸ ì‚¬ìš©ì ìƒí˜¸ ì‘ìš© ì¤‘ì— ë©”ëª¨ë¦¬ í• ë‹¹ì„ ê¸°ë¡í•˜ì—¬
 ì½”ë“œê°€ ì§§ì€ ì‹œê°„ì— ë„ˆë¬´ ë§ì€ ê°œì²´ë¥¼ í• ë‹¹í•˜ê±°ë‚˜ ëˆ„ìˆ˜ë˜ëŠ” ê°œì²´ë¥¼ í• ë‹¹í•˜ëŠ” ìœ„ì¹˜ë¥¼ ì •í™•íˆ ì‹ë³„í•©ë‹ˆë‹¤.   
    
#### For information about programming practices that can reduce your app's memory use, read Manage your app's memory.   
ì•±ì˜ ë©”ëª¨ë¦¬ë¥¼ ì¤„ì¼ ìˆ˜ ìˆëŠ” í”„ë¡œê·¸ë˜ë° ë°©ë²•ì— ëŒ€í•œ ì •ë³´ëŠ” ì•± ë©”ëª¨ë¦¬ ê´€ë¦¬ë¥¼ ì½ìœ¼ì„¸ìš”   
   
   
   
---------------------------------------------------------------------------

## ğŸ“— ë‹¨ì–´ ì •ë¦¬ ğŸ“˜   
   
|ì˜ì–´|í•œê¸€|
|---|---|
|identify|ì‹ë³„|
|memory allocations|ë©”ëª¨ë¦¬ í• ë‹¹|
|no longer|ë” ì´ìƒ|
|also see|ë˜í•œ ì°¸ì¡°|
|constantly|ì§€ì†ì ìœ¼ë¡œ| 
|satisfy|ì¶©ì¡±ì‹œí‚¤ë‹¤, ë§Œì¡±ì‹œí‚¤ë‹¤, í’€ë‹¤|
|enough memory|ì¶©ë¶„í•œ ë©”ëª¨ë¦¬|
|retain|ìœ ì§€|
|unnecessary|ë¶ˆí•„ìš”í•œ, ë¶ˆí•„ìš”í•œ ê²ƒ| 
|Eventually|ê²°êµ­|
|reclaim|ë˜ì°¾ë‹¤.|
|completely|ì™„ì „íˆ|
|reduce|ì¤„ì´ë‹¤|
