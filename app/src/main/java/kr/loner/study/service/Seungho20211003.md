# ì˜ì–´ìŠ¤í„°ë”” ì‹œì¦Œ 4 2ì£¼ì°¨

created by [seungho](https://github.com/devaspirant0510) on 2021-10-03

# ğŸ“— ë‹¨ì–´ ì •ë¦¬ ğŸ“˜

|ì˜ì–´|í•œê¸€|
|---|---|
|due to|~ë•Œë¬¸ì—|
|moreover |ê²Œë‹¤ê°€|
|compatible|í˜¸í™˜|
|replace|~ì„ ëŒ€ì‹ í•˜ì—¬|
|serially|ì—°ì†ì ìœ¼ë¡œ|
|one after another|ì°¨ë¡€ë¡œ|
|simultaneously|ë™ì‹œì—|
|suitable|ì ì ˆí•œ|
|immediately|ì¦‰ì‹œ|
|resumed|ì¬ê²Œ|

___
__The Service class is the base class for all services.__  
`ì„œë¹„ìŠ¤ í´ë˜ìŠ¤ëŠ” ëª¨ë“  ì„œë¹„ìŠ¤ì˜ ê¸°ë³¸ í´ë˜ìŠ¤ë‹¤`

__When you extend this class, it's important to create a new thread in which the service 
can complete all of its work;__  
`ë„ˆê°€ ì„œë¹„ìŠ¤ í´ë˜ìŠ¤ë¥¼ í™•ì¥í• ë•Œ ëª¨ë“  ì‘ì—…ì„ ì™„ë£Œí• ìˆ˜ ìˆëŠ” ìƒˆë¡œìš´ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ëŠ”ê²ƒì´ ì¤‘ìš”í•˜ë‹¤ `

__the service uses your application's main thread by default, which can slow the performance
of any activity that your application is running.__  
`ì„œë¹„ìŠ¤ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ë„ˆì˜ ì•±ì˜ ë©”ì¸ìŠ¤ë ˆë“œì—ì„œ ì‚¬ìš©ë˜ë¯€ë¡œ ë„ˆì˜ ì• í”Œë¦¬ì¼€ì´ì…˜ ì„±ëŠ¥ì´ ë‚®ì•„ì§ˆìˆ˜ ìˆë‹¤.`

__The Android framework also provides the IntentService subclass of Service that uses a
worker thread to handle all of the start requests, one at a time.__  
`ì•ˆë“œë¡œì´ë“œ í”„ë ˆì„ ì›Œí¬ëŠ” ë˜í•œ ì›Œì»¤ ìŠ¤ë ˆë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ëª¨ë“  ìš”ì²­ì„ í•œë²ˆì— í•˜ë‚˜ì”© ì²˜ë¦¬í•˜ëŠ” 
ì„œë¹„ìŠ¤ì˜ ì„œë¸Œí´ë˜ìŠ¤ì¸ IntentServiceë¥¼ ì œê³µí•œë‹¤. `

__Using this class is not recommended for new apps as it will not work well starting with 
Android 8 Oreo, due to the introduction of Background execution limits.__   
`ì´ í´ë˜ìŠ¤ë¥¼ë¥¼ ì‹ ê·œì•±ì— ì‚¬ìš©í•˜ëŠ”ê²ƒì„ ì¶”ì²œí•˜ì§€ ì•ŠëŠ”ë‹¤  Background execution limits 
ë„ì…ìœ¼ë¡œ ì‹ ê·œ ì•± Android 8 Oreo ë¶€í„°ëŠ” ì‘ë™í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ`

__Moreover, it's deprecated starting with Android 11.__  
`ê²Œë‹¤ê°€ ì´ê²ƒì€ Android 11 ë¶€í„° Deprecated ë˜ì—ˆë‹¤.`

__You can use JobIntentService as a replacement for IntentService that is compatible 
with newer versions of Android.__  
`ë„ˆëŠ” IntentService ë¥¼ ëŒ€ì²´í•˜ì—¬ ì•ˆë“œë¡œì´ë“œ ìµœì‹ ë²„ì „ê³¼ í˜¸í™˜ë˜ëŠ” JobIntentService ë¥¼ ì‚¬ìš©í• ìˆ˜ìˆë‹¤. `

__The following sections describe how you can implement your own custom service, however 
you should strongly consider using WorkManager instead for most use cases.__   
`ë‹¤ìŒì— ë‚˜ì˜¤ëŠ” ì„¹ì…˜ì—ì„œ ì–´ë–»ê²Œ ë„ˆê°€ ë„ˆì˜ ê³ ìœ í•œ ì„œë¹„ìŠ¤ë¥¼ êµ¬í˜„í•˜ëŠ”ì§€ ë‚˜ì˜¤ì§€ë§Œ ë„ˆëŠ” ëŒ€ë¶€ë¶„ì˜ê²½ìš° 
Workmanger ë¥¼ ëŒ€ì‹ í•´ì„œ ì‚¬ìš©í•˜ëŠ”ê²ƒì„ ê³ ë ¤í•´ì•¼í•œë‹¤.`

__Consult <b>the guide to background processing on Android</b> to see if there is a solution 
that fits your needs.__  
`ë„ˆì—ê²Œ ë§ëŠ” ì†”ë£¨ì…˜ì„ ì°¾ê³ ì‹¶ìœ¼ë©´ ì•ˆë“œë¡œì´ë“œì—ì„œ  ë°±ê·¸ë¼ìš´ë“œ ì²˜ë¦¬ ì•ˆë‚´ì„œ ë¥¼ ì°¸ê³ í•˜ì„¸ìš”`  

__Extending the Service class__   
`ì„œë¹„ìŠ¤ í´ë˜ìŠ¤ í™•ì¥`  
__You can extend the Service class to handle each incoming intent.
Here's how a basic implementation might look:__  
`ë„ˆëŠ” ì„œë¹„ìŠ¤ í´ë˜ìŠ¤ë¥¼ í™•ì¥í•˜ì—¬ ë“¤ì–´ì˜¤ëŠ” ì¸í…íŠ¸ë¡œ ì²˜ë¦¬í• ìˆ˜ ìˆë‹¤  ì—¬ê¸° ì‹œë³¸êµ¬í˜„ëœ ì½”ë“œë¥¼ ë³´ë¼`  
```kotlin
class HelloService : Service() {

    private var serviceLooper: Looper? = null
    private var serviceHandler: ServiceHandler? = null

    // Handler that receives messages from the thread
    private inner class ServiceHandler(looper: Looper) : Handler(looper) {

        override fun handleMessage(msg: Message) {
            // Normally we would do some work here, like download a file.
            // For our sample, we just sleep for 5 seconds.
            try {
                Thread.sleep(5000)
            } catch (e: InterruptedException) {
                // Restore interrupt status.
                Thread.currentThread().interrupt()
            }

            // Stop the service using the startId, so that we don't stop
            // the service in the middle of handling another job
            stopSelf(msg.arg1)
        }
    }

    override fun onCreate() {
        // Start up the thread running the service.  Note that we create a
        // separate thread because the service normally runs in the process's
        // main thread, which we don't want to block.  We also make it
        // background priority so CPU-intensive work will not disrupt our UI.
        HandlerThread("ServiceStartArguments", Process.THREAD_PRIORITY_BACKGROUND).apply {
            start()

            // Get the HandlerThread's Looper and use it for our Handler
            serviceLooper = looper
            serviceHandler = ServiceHandler(looper)
        }
    }

    override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int {
        Toast.makeText(this, "service starting", Toast.LENGTH_SHORT).show()

        // For each start request, send a message to start a job and deliver the
        // start ID so we know which request we're stopping when we finish the job
        serviceHandler?.obtainMessage()?.also { msg ->
            msg.arg1 = startId
            serviceHandler?.sendMessage(msg)
        }

        // If we get killed, after returning from here, restart
        return START_STICKY
    }

    override fun onBind(intent: Intent): IBinder? {
        // We don't provide binding, so return null
        return null
    }

    override fun onDestroy() {
        Toast.makeText(this, "service done", Toast.LENGTH_SHORT).show()
    }
}
```
__The example code handles all incoming calls in onStartCommand() and posts the work to a Handler 
running on a background thread.__    
`ì˜ˆì‹œ ì½”ë“œì—ì„œ ì²˜ë¦¬í•œë‹¤ ë“¤ì–´ì˜¤ëŠ” ëª¨ë“ ê²ƒì€ onStartCommand() ì•ˆì—ì„œ í˜¸ì¶œë˜ê³ , ì‘ì—…ì„ ë°±ê·¸ë¼ìš´ë“œìŠ¤ë ˆë“œì—ì„œ ëŒê³ ìˆëŠ”
í•¸ë“¤ëŸ¬ì— ê²Œì‹œí•œë‹¤.`  

__It works just like an IntentService and processes all requests serially, one after another.__    
`ì´ ì‘ì—…ì€ ë‹¨ì§€ IntentService ì²˜ëŸ¼ ë™ì‘ë˜ê³  ëª¨ë“  ìš”ì²­ì„ ì—°ì†ì ìœ¼ë¡œ,ì°¨ë¡€ë¡œ ì²˜ë¦¬í•œë‹¤, `  

__You could change the code to run the work on a thread pool, for example, if you'd like to 
run multiple requests simultaneously.__  
`ë„ˆëŠ” ë°”ê¿€ìˆ˜ ìˆë‹¤ ì½”ë“œë¥¼ ìŠ¤ë ˆë“œí’€ì—ì„œ ë™ì‘í•˜ê²Œ ì˜ˆë¥¼ë“¤ì–´ ë§Œì•½ ë„ˆê°€ ì—¬ëŸ¬ ìš”ì²­ì„ ë™ì‹œì— ì²˜ë¦¬í•˜ê³  ì‹¶ì„ë•Œ `  

__Notice that the onStartCommand() method must return an integer.__   
`onStartCommand() ë©”ì„œë“œê°€ ë§Œë“œì‹œ intë¥¼ ë¦¬í„´í•˜ëŠ”ê±¸ ê¸°ì–µí•´ë¼ `  
__The integer is a value that describes how the system should continue the service in the event 
that the system kills it.__     
`intger ëŠ” ì‹œìŠ¤í…œì´ ì£½ì—ˆì„ê²½ìš° ì–´ë–»ê²Œ ì„œë¹„ìŠ¤ë¥¼ ê³„ì†í•´ì•¼í•˜ëŠ” ë°©ë²•ì„ ì„¤ëª…í•˜ëŠ” ê°’ì´ë‹¤.`  
__The return value from onStartCommand() must be one of the following constants:__  
`ë°˜í™˜ ê°’ì€ onstartCommand() ë¡œë¶€í„° ë°˜ë“œì‹œ ë‹¤ìŒì— ë‚˜ì˜¤ëŠ” ìƒìˆ˜ì¤‘ í•˜ë‚˜ì—¬ì•¼í•œë‹¤.`  

### START_NOT_STICKY
__If the system kills the service after onStartCommand() returns, do not recreate the service 
unless there are pending intents to deliver.__    
`ë§Œì•½ ì‹œìŠ¤í…œì´ ì£½ì—ˆì„ë•Œ ì„œë¹„ìŠ¤ê°€ onstartCommand() ë¦¬í„´ í›„ ì œê³µí•  peding intent ì—†ëŠ”í•œ ë‹¤ì‹œ ì„œë¹„ìŠ¤ë¥¼ 
ì¬ìƒì„±í•˜ì§€ ë§ˆë¼. `  
__This is the safest option to avoid running your service when not necessary and 
when your application can simply restart any unfinished jobs.__    
`í•„ìš”í•˜ì§€ ì•Šì„ë•Œì™€ ë„ˆì˜ ì•±ì´ ì™„ë£Œë˜ì§€ ì•Šì€ ì‘ì—…ì„ ì¬ì‹œì‘í• ìˆ˜ ìˆì„ë•Œ  ì„œë¹„ìŠ¤ì‹¤í–‰ì„ ë§‰ëŠ” ê°€ì¥ ì•ˆì „í•œ ë°©ë²•ì…ë‹ˆë‹¤. `    
### START_STICKY
__If the system kills the service after onStartCommand() returns, recreate the
service and call onStartCommand(), but do not redeliver the last intent.__  
`ë§Œì•½ ì„œë¹„ìŠ¤ê°€ ì£½ìœ¼ë©´ ì„œë¹„ìŠ¤ê°€ onStartCommand() ë¦¬í„´í›„, ê·¸ ì„œë¹„ ì„œë¹„ìŠ¤ë¥¼ ì¬ì„±ì„±í•˜ê³  
onStartCommand() ë¥¼ í˜¸ì¶œí•˜ì§€ë§Œ, ê·¸ëŸ¬ë‚˜ ë§ˆì§€ë§‰ ì¸í…íŠ¸ë¥¼ ë‹¤ì‹œì „ë‹¬í•˜ì§€ë§ˆë¼ `    
__Instead, the system calls onStartCommand() with a null intent unless there are 
pending intents to start the service. In that case, those intents are delivered.__    
`ëŒ€ì‹ ì— ì‹œìŠ¤í…œì´ onStartCommand()ë¥¼  null intent ë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ”í•œ íœë”© ì¸í…íŠ¸ë¥¼ ì„œë¹„ìŠ¤ë¥¼ ì‹œì‘í•œë‹¤. 
ëŒ€ë¶€ë¶„ì˜ ê²½ìš° ì¸í…íŠ¸ê°€ ì „ë‹¬ëœë‹¤.
`

__This is suitable for media players (or similar services) that are not executing 
commands but are running indefinitely and waiting for a job.__  
`ì´ê²ƒì€ ëª…ë ¹ì„ í• ìˆ˜ ì—†ì§€ë§Œ ë¬´í•œíˆ ì‹¤í–‰í•˜ê±°ë‚˜ ì‘ì—…ì„ ëŒ€ê¸°í• ìˆ˜ ìˆëŠ” ë¯¸ë””ì–´ í”Œë ˆì´ì–´ì— ì ì ˆí•˜ë‹¤.`  
### START_REDELIVER_INTENT
__If the system kills the service after onStartCommand() returns, recreate the
service and call onStartCommand() with the last intent that was delivered to the service.__  
`ë§Œì—­ ì‹œìŠ¤í…œì´ ì£½ì„ë•Œ onstartCommand() ê°€ ë°˜í™˜ëœí›„, ì¬ì„±ì„±í•œë‹¤. ì„œë¹„ìŠ¤ì— ì „ë‹¬ëœ intentë¥¼ 
onStartCommand()ì— í˜¸ì¶œí•œë‹¤.`

__Any pending intents are delivered in turn.__   
`ë³´ë¥˜ì¤‘ì¸ ì¸í…íŠ¸ëŠ” ì°¨ë¡€ë¡œ ì „ë‹¬ëœë‹¤.`

__This is suitable for services that are actively performing a job that should be 
immediately resumed, such as downloading a file.__  
`ì´ê²ƒì€ íŒŒì¼ ë‹¤ìš´ë¡œë“œì™€ ê°™ì´ ì¦‰ì‹œ ì¬ê°œë˜ì–´ì•¼ë˜ëŠ” í™œë™ì ì¸ ì‘ì—…ì„ ìˆ˜í–‰í•´ì•¼ë ë–„ ì ì ˆí•˜ë‹¤.`

__For more details about these return values, see the linked reference documentation 
for each constant.__  
`ë” ë§ì€ ìƒìˆ˜ê°’ì—ëŒ€í•œ ë°˜í™˜ê°’ ì •ë³´ëŠ” ë§í¬ëœ ë¬¸ì„œì—ì„œ `