# ì˜ì–´ìŠ¤í„°ë”” ì‹œì¦Œ 4 3ì£¼ì°¨

created by [seungho](https://github.com/devaspirant0510) on 2021-10-03

# ðŸ“— ë‹¨ì–´ ì •ë¦¬ ðŸ“˜

### starting a service

__You can start a service from an activity or other application component
by passing an Intent to startService() or startForegroundService().__  
`ë„ˆëŠ” ì‹œìž‘í• ìˆ˜ ìžˆë‹¤ ì„œë¹„ìŠ¤ë¥¼ ì•¡í‹°ë¹„í‹° ë˜ëŠ” ë‹¤ë¥¸ 4ëŒ€ ì»´í¬ë„ŒíŠ¸ì—ì„œ startService() ë˜ëŠ” startForegroundService()
intent ë¥¼ í†µí•´ì„œ`  

__The Android system calls the service's onStartCommand() method and
passes it the Intent, which specifies which service to start.__   
`ì•ˆë“œë¡œì´ë“œ ì‹œìŠ¤í…œì€ `

> __Note: If your app targets API level 26 or higher, the system imposes 
> restrictions on using or creating background services unless the app 
> itself is in the foreground.__   
> `s`  
> __If an app needs to create a foreground service,
> the app should call startForegroundService().__   
> ` `  
> __That method creates a background service, but the method signals to the system that the 
> service will promote itself to the foreground.__   
> ` `  
> __Once the service has been created, the service must call its startForeground() 
> method within five seconds.__  
> ` `  

__For example, an activity can start the example service in the previous section 
(HelloService) using an explicit intent with startService(), as shown here:__  
` `

```kotlin
Intent(this, HelloService::class.java).also { intent ->
    startService(intent)
}
```

__The startService() method returns immediately, and the Android system calls the service's 
onStartCommand() method. If the service isn't already running, 
the system first calls onCreate(), and then it calls onStartCommand().__

__If the service doesn't also provide binding, the intent that is delivered with startService() 
is the only mode of communication between the application component and the service.__

However, if you want the service to send a result back, the client that starts the service can create a PendingIntent for a broadcast (with getBroadcast()) and deliver it to the service in the Intent that starts the service. The service can then use the broadcast to deliver a result.

Multiple requests to start the service result in multiple corresponding calls to the service's onStartCommand(). However, only one request to stop the service (with stopSelf() or stopService()) is required to stop it.


### Stopping a Service
A started service must manage its own lifecycle. That is, the system doesn't stop or destroy the service unless it must recover system memory and the service continues to run after onStartCommand() returns. The service must stop itself by calling stopSelf(), or another component can stop it by calling stopService().

Once requested to stop with stopSelf() or stopService(), the system destroys the service as soon as possible.

If your service handles multiple requests to onStartCommand() concurrently, you shouldn't stop the service when you're done processing a start request, as you might have received a new start request (stopping at the end of the first request would terminate the second one). To avoid this problem, you can use stopSelf(int) to ensure that your request to stop the service is always based on the most recent start request. That is, when you call stopSelf(int), you pass the ID of the start request (the startId delivered to onStartCommand()) to which your stop request corresponds. Then, if the service receives a new start request before you are able to call stopSelf(int), the ID doesn't match and the service doesn't stop.

Caution: To avoid wasting system resources and consuming battery power, ensure that your application stops its services when it's done working. If necessary, other components can stop the service by calling stopService(). Even if you enable binding for the service, you must always stop the service yourself if it ever receives a call to onStartCommand().

For more information about the lifecycle of a service, see the section below about Managing the Lifecycle of a Service.
