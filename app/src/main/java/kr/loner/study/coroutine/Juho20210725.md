# Kotlin coroutines on Android

- ì½”ë£¨í‹´ì€ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì‹¤í–‰ë˜ëŠ” ì½”ë“œë¥´ ê°„ì†Œí™”í•˜ê¸° ìœ„í•´ ì‚¬ìš©í•˜ëŠ” ì‹¤í–‰ ì„¤ê³„ íŒ¨í„´ì´ë‹¤.
- ì‹¤í–‰ì¤‘ì¸ ìŠ¤ë ˆë“œë¥¼ ì°¨ë‹¨í•˜ì§€ ì•Šê³  ì •ì§€í•˜ë¯€ë¡œ ë‹¨ì¼ ìŠ¤ë ˆë“œì—ì„œ ë§ì€ ì½”ë£¨í‹´ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
- ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ê°€ ê°ì†Œí•œë‹¤.
- ì‹¤í–‰ì¤‘ì¸ ì½”ë£¨í‹´ì€ ê³„ì¸µ êµ¬ì¡°ë¥¼ í†µí•´ ìë™ìœ¼ë¡œ ì·¨ì†Œëœë‹¤.
- ì­íŒ© ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì§€ì›ëœë‹¤.

### Interpretation

### Kotlin coroutines on Android

A coroutine is a concurrency design pattern that you can use on Android to simplify code that executes asynchronously. Coroutines were added to Kotlin in version 1.3 and are based on established concepts from other languages.

ì½”ë£¨í‹´ì€ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì‹¤í–‰ë˜ëŠ” ì½”ë“œë¥¼ ê°„ì†Œí™”í•˜ê¸° ìœ„í•´ ì•ˆë“œë¡œì´ë“œì—ì„œ ì‚¬ìš©í•˜ëŠ” ë³‘í–‰ ë””ìì¸ íŒ¨í„´ì´ë‹¤. ì½”ë£¨í‹´ì€ ì½”í‹€ë¦° ë²„ì „ 1.3ì—ì„œ ì¶”ê°€ë˜ì—ˆê³  ë‹¤ë¥¸ ì–¸ì–´ì—ì„œ í™•ë¦½ëœ ê°œë…ì„ ê¸°ë°˜ìœ¼ë¡œ í•œë‹¤.

On Android, coroutines help to manage long-running tasks that might otherwise block the main thread and cause your app to become unresponsive. Over 50% of professional developers who use coroutines have reported seeing increased productivity. This topic describes how you can use Kotlin coroutines to address these problems, enabling you to write cleaner and more concise app code.

ì•ˆë“œë¡œì´ë“œì—ì„œ ì½”ë£¨í‹´ì€ ë©”ì¸ìŠ¤ë ˆë“œê°€ ì°¨ë‹¨ë˜ê±°ë‚˜ ì•±ì—ì„œ ë¯¸ë°˜ì‘ì„ ì•¼ê¸°í•  ìˆ˜ ìˆëŠ” ì¥ê¸° ì‹¤í–‰ ì‘ì—…ì„ ê´€ë¦¬í•˜ëŠ”ë° ë„ì›€ì„ ì¤€ë‹¤. ì½”ë£¨í‹´ì„ ì‚¬ìš©í•˜ëŠ” ì „ë¬¸ê°€ë“¤ì˜ ì ˆë°˜ ì´ìƒì€ ìƒì‚°ì„±ì´ ì¦ê°€í–ˆë‹¤ê³  ë³´ê³ í–ˆë‹¤. ì´ ì£¼ì œì—ì„œëŠ” ì–´ë–»ê²Œ ê°„ê²°í•˜ê³  ê¹”ë”í•œ ì½”ë“œê°€ ì‚¬ìš©í•˜ë©´ì„œ ì´ëŸ¬í•œ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸°ìœ„í•œ ì½”ë£¨í‹´ì„ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì„ ì„¤ëª…í•œë‹¤.

### Features

Coroutines is our recommended solution for asynchronous programming on Android. Noteworthy features include the following:

ì½”ë£¨í‹´ì€ ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë°ì— ê¶Œì¥ë˜ëŠ” ì†”ë£¨ì…˜ì´ë‹¤. ì£¼ëª©í• ë§Œí•œ íŠ¹ì§•ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

- Lightweight: You can run many coroutines on a single thread due to support for suspension, which doesn't block the thread where the coroutine is running. Suspending saves memory over blocking while supporting many concurrent operations.

ê²½ëŸ‰: ì½”ë£¨í‹´ì´ ì‹¤í–‰í•  ë•Œ ìŠ¤ë ˆë“œë¥¼ ì°¨ë‹¨í•˜ì§€ì•Šê³  ì¤‘ì§€ë¥¼ ì§€ì›í•˜ê¸°ë•Œë¬¸ì— ë‹¨ì¼ ìŠ¤ë ˆë“œì—ì„œ ë§ì€ ì½”ë£¨í‹´ì„ ì‹¤í–‰í•  ìˆ˜ ìˆë‹¤. ì¤‘ì§€ëŠ” ìˆ˜ ë§ì€ ë³‘í–‰ ì‘ì—…ì„ í•˜ëŠ” ë™ì•ˆ ì°¨ë‹¨ë³´ë‹¤ ë©”ëª¨ë¦¬ë¥¼ ì ˆì•½í•œë‹¤.

- Fewer memory leaks: Use structured concurrency to run operations within a scope.
ì ì€ ë©”ëª¨ë¦¬ ë‚­ë¹„ : êµ¬ì¡°í™”ëœ ë³‘í–‰ì„±ì„ ì‚¬ìš©í•´ì„œ ë²”ìœ„ ë‚´ì—ì„œ ì—°ì‚°í•œë‹¤.

- Built-in cancellation support: Cancellation is propagated automatically through the running coroutine hierarchy.

ê¸°ë³¸ìœ¼ë¡œ ì œê³µë˜ëŠ” ì·¨ì†Œ : ì·¨ì†ŒëŠ” ì½”ë£¨í‹´ ê³„ì¸µì„ í†µí•´ ìë™ìœ¼ë¡œ ì „ë‹¬ëœë‹¤.

- Jetpack integration: Many Jetpack libraries include extensions that provide full coroutines support. Some libraries also provide their own coroutine scope that you can use for structured concurrency.

ì­íŒ© í†µí•© : ë§ì€ ì­íŒ© ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì§€ì›í•œë‹¤. ëª‡ëª‡ ë¼ì´ë¸ŒëŸ¬ë¦¬ë„ ë³‘í–‰ êµ¬ì¡°ë¡œ ì½”ë£¨í‹´ ë²”ìœ„ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

### Examples overview

Based on the Guide to app architecture, the examples in this topic make a network request and return the result to the main thread, where the app can then display the result to the user.

ì•± ì•„í‚¤í…ì²˜ ê°€ì´ë“œë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì´ ì£¼ì œì˜ ì˜ˆì œëŠ” ë©”ì¸ ìŠ¤ë ˆë“œì—ì„œ ë„¤íŠ¸ì›Œí¬ ìš”ì²­ê³¼ ë°˜í™˜ì„ í•œë‹¤. ê·¸ë¦¬ê³  ì•±ì€ ìœ ì €ì—ê²Œ ê²°ê³¼ë¥¼ í‘œì‹œí•  ìˆ˜ ìˆë‹¤.

Specifically, the ViewModel Architecture component calls the repository layer on the main thread to trigger the network request. This guide iterates through various solutions that use coroutines keep the main thread unblocked.

íŠ¹íˆ ë·°ëª¨ë¸ ì•„í‚¤í…ì²˜ ì»´í¬ë„ŒíŠ¸ëŠ” ë©”ì¸ìŠ¤ë ˆë“œì—ì„œ íŠ¸ë¦¬ê±° í•˜ê¸°ìœ„í•´ ì €ì¥ì†Œ ë ˆì´ì•„ì›ƒì„ í˜¸ì¶œí•œë‹¤. ì´ ê°€ì´ë“œì—ì„œëŠ” ì°¨ë‹¨ë˜ì§€ ì•Šì€ ë©”ì¸ìŠ¤ë ˆë“œë¥¼ ìœ ì§€í•˜ë©° ì½”ë£¨í‹´ì„ ì‚¬ìš©í•˜ëŠ” ë‹¤ì–‘í•œ í•´ê²°ì±…ì„ ë°˜ë³µí•œë‹¤.

ViewModel includes a set of KTX extensions that work directly with coroutines. These extension are lifecycle-viewmodel-ktx library and are used in this guide.

ë·°ëª¨ë¸ì€ ì½”ë£¨í‹´ê³¼ ì§ì ‘ ì‘ì—…í•˜ëŠ” ktxë¥¼ í¬í•¨í•œë‹¤. ì´ëŸ° í™•ì¥ì€ lvk ë¼ì´ë¸ŒëŸ¬ë¦¬ì´ë©° ê°€ì´ë“œì—ì„œ ì‚¬ìš©ëœë‹¤.


### Executing in a background thread

Making a network request on the main thread causes it to wait, or block, until it receives a response. Since the thread is blocked, the OS isn't able to call onDraw(), which causes your app to freeze and potentially leads to an Application Not Responding (ANR) dialog. For a better user experience, let's run this operation on a background thread.

ë©”ì¸ìŠ¤ë ˆë“œì—ì„œ ë„¤íŠ¸ì›Œí¬ìš”ì²­ ìƒì„±ì€ ì‘ë‹µì„ ë°›ì„ ë•Œê¹Œì§€ ëŒ€ê¸°í•˜ê±°ë‚˜ ì°¨ë‹¨ëœë‹¤. ìŠ¤ë ˆë“œê°€ ì°¨ë‹¨ëœ ì´í›„ ìš´ì˜ì²´ì œëŠ” onDraw ë©”ì†Œë“œë¥¼ í˜¸ì¶œí•  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ì•±ì˜ ì¤‘ì§€ë¥¼ ì•¼ê¸°ì‹œí‚¤ê³  ê¶ê·¹ì ìœ¼ë¡œ ANR ë‹¤ì´ì–¼ë¡œê·¸ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ìˆë‹¤. ë” ë‚˜ì€ ì‚¬ìš©ì í™˜ê²½ì„ ìœ„í•´ ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œì—ì„œ ì‘ì—…ì„ ì‹¤í–‰í•´ë³´ì.

First, let's take a look at our Repository class and see how it's making the network request:

ì²«ì§¸ë¡œ Repository í´ë˜ìŠ¤ì™€ ì–´ë–»ê²Œ ë„¤íŠ¸ì›Œí¬ ìš”ì²­ì„ í•˜ëŠ”ì§€ ë³´ì.

sealed class Result<out R> {
    data class Success<out T>(val data: T) : Result<T>()
    data class Error(val exception: Exception) : Result<Nothing>()
}

class LoginRepository(private val responseParser: LoginResponseParser) {
    private const val loginUrl = "https://example.com/login"

    // Function that makes the network request, blocking the current thread
    fun makeLoginRequest(
        jsonBody: String
    ): Result<LoginResponse> {
        val url = URL(loginUrl)
        (url.openConnection() as? HttpURLConnection)?.run {
            requestMethod = "POST"
            setRequestProperty("Content-Type", "application/json; utf-8")
            setRequestProperty("Accept", "application/json")
            doOutput = true
            outputStream.write(jsonBody.toByteArray())
            return Result.Success(responseParser.parse(inputStream))
        }
        return Result.Error(Exception("Cannot open HttpURLConnection"))
    }
}

makeLoginRequest is synchronous and blocks the calling thread. To model the response of the network request, we have our own Result class.
The ViewModel triggers the network request when the user clicks, for example, on a button:

makeLoginRequestì€ ë™ê¸°ì‹ì´ë©° í˜¸ì¶œí•˜ëŠ” ìŠ¤ë ˆë“œë¥¼ ì°¨ë‹¨í•œë‹¤. ë„¤íŠ¸ì›Œí¬ìš”ì²­ì˜ ì‘ë‹µì— ëª¨ë¸ë§ í•˜ê¸° ìœ„í•´ Result í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•œë‹¤. ë·°ëª¨ë¸ì€ ì‚¬ìš©ìì˜ í´ë¦­(ex.ë²„íŠ¼)ì˜ ë„¤íŠ¸ì›Œí¬ ìš”ì²­ì„ íŠ¸ë¦¬ê±°í•©ë‹ˆë‹¤.

class LoginViewModel(
    private val loginRepository: LoginRepository
): ViewModel() {

    fun login(username: String, token: String) {
        val jsonBody = "{ username: \"$username\", token: \"$token\"}"
        loginRepository.makeLoginRequest(jsonBody)
    }
}

With the previous code, LoginViewModel is blocking the UI thread when making the network request. The simplest solution to move the execution off the main thread is to create a new coroutine and execute the network request on an I/O thread:

ì•ì„  ì½”ë“œì—ì„œ LoginViewModelì€ ë„¤íŠ¸ì›Œí¬ ìš”ì²­ì‹œ UIìŠ¤ë ˆë“œë¥¼ ì°¨ë‹¨í•œë‹¤. ë©”ì¸ìŠ¤ë ˆë“œ ì™¸ë¶€ë¡œ ì‹¤í–‰ì„ ì˜®ê¸°ëŠ” ê°€ì¥ ê°„ë‹¨í•œ í•´ê²° ë°©ë²•ì€ ìƒˆë¡œìš´ ì½”ë£¨í‹´ì„ ë§Œë“¤ê³  I/O ìŠ¤ë ˆë“œì—ì„œ ë„¤íŠ¸ì›Œí¬ ìš”ì²­ì„ ì‹¤í–‰í•˜ëŠ” ê²ƒì´ë‹¤.

class LoginViewModel(
    private val loginRepository: LoginRepository
): ViewModel() {

    fun login(username: String, token: String) {
        // Create a new coroutine to move the execution off the UI thread
        viewModelScope.launch(Dispatchers.IO) {
            val jsonBody = "{ username: \"$username\", token: \"$token\"}"
            loginRepository.makeLoginRequest(jsonBody)
        }
    }
}

Let's dissect the coroutines code in the login function:

 - viewModelScope is a predefined CoroutineScope that is included with the ViewModel KTX extensions. Note that all coroutines must run in a scope. A CoroutineScope manages one or more related coroutines.

ë·°ëª¨ë¸ ìŠ¤ì½”í”„ëŠ” ktxì— í¬í•¨ëœ ì‚¬ì „ ì •ì˜ëœ ì½”ë£¨í‹´ ìŠ¤ì½”í”„ì´ë‹¤. ëª¨ë“  ì½”ë£¨í‹´ì€ ë²”ìœ„ë‚´ì—ì„œ ì‹¤í–‰ë˜ì–´ì•¼í•œë‹¤. ì½”ë£¨í‹´ ìŠ¤ì½”í”„ëŠ” í•˜ë‚˜ ì´ìƒì˜ ì½”ë£¨í‹´ì„ ê´€ë¦¬í•œë‹¤.

- launch is a function that creates a coroutine and dispatches the execution of its function body to the corresponding dispatcher.

ëŸ°ì²˜ëŠ” ì½”ë£¨í‹´ì„ ë§Œë“¤ê³  ê·¸ ë©”ì†Œë“œë¥¼ ì‹¤í–‰í•˜ëŠ” ë””ìŠ¤íŒ¨ì²˜ì´ë‹¤.

-Dispatchers.IO indicates that this coroutine should be executed on a thread reserved for I/O operations.

IOë””ìŠ¤íŒ¨ì²˜ëŠ” ì½”ë£¨í‹´ì„ I/O ì‘ì—…ì„ ì˜ˆì•½ëœ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰í•´ì•¼í•¨ì„ ë‚˜íƒ€ë‚¸ë‹¤.

The login function is executed as follows:

- The app calls the login function from the View layer on the main thread.

ì•±ì€ ë©”ì¸ìŠ¤ë ˆë“œì—ì„œ ë·°ë ˆì´ì•„ì›ƒìœ¼ë¡œë¶€í„° ë¡œê·¸ì¸ ë©”ì†Œë“œë¥¼ í˜¸ì¶œí•œë‹¤.

- launch creates a new coroutine, and the network request is made independently on a thread reserved for I/O operations.

ëŸ°ì²˜ëŠ” ìƒˆë¡œìš´ ì½”ë£¨í‹´ì„ ìƒì„±í•˜ê³  ë„¤íŠ¸ì›Œí¬ ìš”ì²­ì€ I/O ì‘ì—…ì— ëŒ€í•œ ì˜ˆì•½ëœ ìŠ¤ë ˆë“œì—ì„œ ë…ë¦½ì ìœ¼ë¡œ ë„¤íŠ¸ì›Œí¬ ìš”ì²­ì´ ì´ë£¨ì–´ ì§„ë‹¤.

- While the coroutine is running, the login function continues execution and returns, possibly before the network request is finished. Note that for simplicity, the network response is ignored for now.

ì½”ë£¨í‹´ì´ ì‹¤í–‰í•˜ëŠ” ë™ì•ˆ ë¡œê·¸ì¸ ë©”ì†Œë“œëŠ” ê°€ëŠ¥í•œ ë„¤íŠ¸ì›Œí¬ ìš”ì²­ì´ ëë‚˜ê¸°ì „ê¹Œì§€ ì‹¤í–‰ê³¼ ë¦¬í„´ì´ ì§€ì†ëœë‹¤. í¸ì˜ë¥¼ ìœ„í•´ í˜„ì¬ ë„¤íŠ¸ì›Œí¬ ìš”ì²­ì€ ë¬´ì‹œëœë‹¤.

Since this coroutine is started with viewModelScope, it is executed in the scope of the ViewModel. If the ViewModel is destroyed because the user is navigating away from the screen, viewModelScope is automatically cancelled, and all running coroutines are canceled as well.

ì´ ì½”ë£¨í‹´ì€ viewModelScopeë¡œ ì‹œì‘ë˜ë¯€ë¡œ ë·°ëª¨ë¸ ë²”ìœ„ì—ì„œ ì‹¤í–‰ëœë‹¤. ë§Œì•½ ë®¤ëª¨ë¸ì´ ì‚¬ìš©ìê°€ í™”ë©´ì„ ë²—ì–´ë‚˜ íŒŒê´´ëœë‹¤ë©´ ë·°ëª¨ë¸ìŠ¤ì½”í”„ëŠ” ìë™ìœ¼ë¡œ ì·¨ì†Œë˜ê³  ì‹¤í–‰ë˜ê³ ìˆëŠ” ëª¨ë“  ì½”ë£¨í‹´ì€ ë§ˆì°¬ê°€ì§€ë¡œ ì·¨ì†Œëœë‹¤.

One issue with the previous example is that anything calling makeLoginRequest needs to remember to explicitly move the execution off the main thread. Let's see how we can modify the Repository to solve this problem for us.

ìœ„ ì˜ˆì œì—ì„œ í•œê°€ì§€ ë¬¸ì œëŠ” makeLoginRequest ë©”ì†Œë“œë¥¼ ìš”ì²­í•˜ëŠ” ê²½ìš° ëª…ì‹œì ìœ¼ë¡œ ì‹¤í–‰ì„ ë§¤ì¸ìŠ¤ë ˆë“œ ì™¸ë¶€ë¡œ ì´ë™í•´ì•¼ í•œë‹¤. ì´ì œ ì´ëŸ° ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ìˆ˜ì •í•˜ëŠ” ë°©ë²•ì„ ì•Œì•„ë³´ì.

---------------------------------------------------------------------------
## ğŸ“— ë‹¨ì–´ ì •ë¦¬ ğŸ“˜   
   
|ì˜ì–´|í•œê¸€|
|---|---|
|concurrency|ë³‘í–‰ì„±|
|concise|ê°„ê²°í•œ|
|Noteworthy features|ì£¼ëª©í• ë§Œí•œ íŠ¹ì§•|
|propagate|ì „ë‹¬í•˜ë‹¤|
|dissect|ë¶„ì„í•˜ë‹¤|
|Note that for simplicity|í¸ì˜ë¥¼ ìœ„í•´|
|explicitly|ëª…ì‹œì ìœ¼ë¡œ|
